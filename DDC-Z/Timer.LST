C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Timer.c BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             Timer.c (v1.00)
   3             
   4             Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "voice.h"
  13          
  14          // ------ Public variable declarations -----------------------------
  15          bit stolen_alarm_flag = 0;    //Ö÷»ú±»µÁ±¨¾¯±êÖ¾£¬1µÄÊ±ºò±íÊ¾´¥·¢    
  16          bit host_stolen_speech_EN = 0;      //Ö÷»ú±»µÁÓïÒôÊ¹ÄÜ£¬1µÄÊ±ºòÔÚmainÖÐÓïÒôÌáÊ¾
  17          bit battery_check=0;    //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎµçÁ¿×ª»»£¬Ö´ÐÐÍêºó£¬½«ÆäÖÃ0
  18          bit position_sensor_EN=0;        //Î»ÖÃ´«¸ÐÆ÷£¬¼´µ¹µØÌ§Æð´«¸ÐÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ÐÆ÷
  19          bit slave_away_speech_EN=0;      //ÅÐ¶Ï¸½»úÀë¿ªºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  20          bit magnet_CW_EN = 0;               //µç´ÅÌúË³Ê±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  21          bit magnet_ACW_EN=0;                //µç´ÅÌúÄæÊ±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  22          bit comm_whole_control=0;           //Í¨ÐÅ×Ü¿ª¹Ø£¬0¹Ø±ÕÍ¨ÐÅ£¬1´ò¿ªÍ¨ÐÅ
  23          tWord host_stolen_speech_count=0;   //ÅÐ¶ÏÖ÷»ú±»µÁºó£¬ÓïÒôÌáÊ¾µÄ´ÎÊý
  24          bit slave_nearby_speech_EN=0;       //ÅÐ¶Ï¸½½ü¿¿½üºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  25          bit host_stolen_alarm1_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒôÊ¹ÄÜ
  26          bit host_stolen_alarm2_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒôÊ¹ÄÜ
  27          tByte host_stolen_alarm1_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒô´ÎÊý
  28          tByte host_stolen_alarm2_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒô´ÎÊý
  29          
  30          // ------ Private variable definitions -----------------------------
  31          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;  //¶¨Ê±Æ÷0ºÍ1µÄ¶¨Ê±Êý¾Ý
  32          
  33          tByte host_touch_speech_count=0;
  34          tByte sensor_trigger_count=0; //´«¸ÐÆ÷´¥·¢¼ÆÊý
  35          tByte host_touched_flag=0;       //Ö÷»ú±»´¥ÅöºóÖÃ1£¬½øÐÐºóÃæµÄ´«¸ÐÆ÷ÅÐ¶Ï
  36          tWord sensor_2ndstage_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊý
  37          tByte sensor_1ststage_count=0;   //´«¸ÐÆ÷µÚÒ»½×¶ÎÅÐ¶ÏµÍµçÆ½µÄ¼ÆÊý
  38          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æðºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  39          bit raised_flag=0;               //ÅÐ¶ÏÖ÷»ú±»Ì§Æðºó£¬ÖÃ1
  40          tByte fell_alarm_count=0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  41          bit fell_flag=0;                 //ÅÐ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  42          tWord timer0_count=0;            //timer0Ã¿´ÎÒç³öºó¼Ó1£¬±íÊ¾ÓÃtimer0¼ÆÊ±
  43          tByte slave_away=0;              //Ä£Ê½Ñ¡ÔñÎ»£¬1ÔòÓÃÄ£Ê½1,2ÔòÓÃÄ£Ê½2,3ÔòÎªÄ£Ê½3
  44          tByte leave_count=0;             //¸½»úÀë¿ªÊ±µÄ¼ÆÊý£¬Ö»Òª¸½»ú3sÓ¦´ðÕýÈ·£¬¾ÍÇå0   
  45          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};     //½ÓÊÕÊý¾Ý»º´æ
  46          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  47          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  48          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  49          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  50          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  51          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  52          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 2   

  53          tByte fell_wire_time=0;          //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  54          tByte raise_wire_time=0;         //Ì§Æð¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  55          tByte sensor_2ndstage_LV_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  56          tByte sensor_2ndstage_count = 0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  57          tByte host_2ndtouch_speech_count = 0;     //Ö÷»ú±»µÚ¶þ´Î´¥Åöºó£¬ÓïÒôÌáÊ¾µÄ´ÎÊý
  58          tWord sensor_3rdstage_time = 0;        //´«¸ÐÆ÷½øÈëµÚÈý½×¶ÎµÄÊ±¼ä£¬
  59          tByte sensor_3rdstage_effcount = 0;    //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬ÓÐÐ§´¥Åö´ÎÊýµÄ¼ÆÊý
  60          tByte sensor_3rdstage_count = 0;       //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬µÍµçÆ½µÄ¼ÆÊý
  61          tWord sensor_3rdstage_interval = 0;    //´«¸ÐÆ÷ÔÚµÚÈý½×¶ÎÖÐ£¬Ã¿´ÎÓÐÐ§µÍµçÆ½¼ÆÊýÖ®¼äµÄÊ±¼ä¼ä¸ô¡£ÔÚÕâÆÚ¼äµÄµÍµ
             -çÆ½²»ÈÏÎªÓÐÐ§¡£
  62          bit host_touch_speech_EN = 0;          //µÚÒ»´Î´¥ÅöºóÓïÒôÊ¹ÄÜ
  63          bit host_2ndtouch_speech_EN = 0;       //µÚ¶þ´Î´¥ÅöºóÓïÒôÊ¹ÄÜ
  64          bit raised_fell_flag = 0;              //µ¹µØ»òÕßÌ§Æð´¥·¢ºó£¬´Ë±êÖ¾Î»ÖÃ1
  65          tWord raised_fell_number = 0;          //µ¹µØ»òÕßÌ§Æð³ö·¢ºó£¬¼ÆÊý£¬µ½´ïÒ»¶¨ÊýÖµºó£¬½«ÆäÓë±êÖ¾Î»Ò»ÆðÇåÁã¡£
  66          
  67          /*------------------------------------------------------------------
  68             timerT0()
  69             ¶¨Ê±Æ÷0Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  70          --------------------------------------------------------------------*/
  71          
  72          void timer0() interrupt interrupt_timer_0_overflow //×÷ÎªÕû¸öÏµÍ³×Ô¼ºµÄÊ±ÖÓ
  73          {
  74   1         TH0 = timer0_8H;
  75   1         TL0 = timer0_8L;
  76   1         
  77   1         timer0_count++;
  78   1      
  79   1         if(timer0_count>=2000)//´®¿ÚÃ¿3s½ÓÊÜÒ»´ÎµÄÊý¾ÝµÄÊ±¼ä±êÖ¾
  80   1         {
  81   2            if(comm_whole_control==1)//ËµÃ÷¿ªÆôÁËÍ¨ÐÅ
  82   2            {
  83   3               leave_count++;
  84   3      
  85   3               if((leave_count>=4&&slave_away==0))
  86   3               {
  87   4                  leave_count=5;
  88   4                  
  89   4                  if(key_rotate == 0)
  90   4                     {
  91   5                        magnet_ACW_EN=1;        //µç´ÅÌúËøÉÏ
  92   5                        slave_away_speech_EN=1;    //±¨¸½»úÀë¿ªÓïÒô
  93   5                        position_sensor_EN=1;      //¿ªÆôµ¹µØ¡¢Ì§Æð±êÖ¾
  94   5                        slave_away=1;
  95   5                     }
  96   4      
  97   4                  sensor_trigger_count=0;
  98   4                  sensor_1ststage_count=0;
  99   4                     
 100   4               }
 101   3            }
 102   2            timer0_count=0;
 103   2            
 104   2            battery_check=1;     
 105   2            
 106   2            if((fell_flag==1)&&(fell_alarm_count<5))  //µ¹µØºó×öÏàÓ¦µÄ¶¯×÷
 107   2            {
 108   3               ComMode_5_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
 109   3               fell_alarm_count++;
 110   3            }
 111   2            if((raised_flag==1)&&(raised_alarm_count<5))    //Ì§Æðºó×öÏàÓ¦¶¯×÷
 112   2            {
 113   3               ComMode_4_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 3   

 114   3               raised_alarm_count++;
 115   3            }
 116   2         }
 117   1      
 118   1         if(sensor_EN==1)     //¼ì²âÈýÖá´«¸ÐÆ÷ÊÇ·ñ´ò¿ª
 119   1            {
 120   2            switch(sensor_trigger_count)
 121   2               {
 122   3               case 0:
 123   3                  {
 124   4                  if((sensor_detect == 0)&&(stolen_alarm_flag == 0))    //¼ì²â´«¸ÐÆ÷Ê±ºòÓÐ±¨¾¯ÐÅºÅ½øÀ´£¬²¢ÇÒÃ»ÓÐÅÐ¶¨Îª±»µÁ
             -¡£¼´ÔÚ±»µÁ±¨¾¯µÄÊ±ºò£¬²»½øÐÐ´Ë¼ì²â
 125   4                     {
 126   5                     sensor_1ststage_count++;
 127   5                     if(sensor_1ststage_count>=2)            //Ã¿1ms¼ì²âÒ»´Î¸ßµçÆ½£¬Èç¹û´óÓÚÁË2msµÄ¸ß¶¨Æ½£¬ËµÃ÷ÓÐÈËÅöÁËÒ»ÏÂ
 128   5                        {
 129   6                        sensor_1ststage_count=0;
 130   6                        sensor_trigger_count = 1;
 131   6                        host_touch_speech_EN = 1;
 132   6                        }
 133   5                     }
 134   4                  else
 135   4                     {
 136   5                     sensor_1ststage_count = 0;
 137   5                     }
 138   4                  }
 139   3               break;
 140   3               
 141   3               case 1:
 142   3                  {
 143   4                  if(sensor_detect == 0)
 144   4                     {
 145   5                     sensor_2ndstage_count++;
 146   5                     if(sensor_2ndstage_count >= 2)
 147   5                        {
 148   6                        sensor_2ndstage_count = 0;
 149   6                        sensor_trigger_count = 2;
 150   6                        host_2ndtouch_speech_EN = 1;
 151   6                        host_2ndtouch_speech_count = 0;
 152   6                        }
 153   5                     }
 154   4                  else
 155   4                     {
 156   5                     sensor_2ndstage_count = 0;
 157   5                     }
 158   4                  
 159   4                  sensor_2ndstage_time++;
 160   4                  if(sensor_2ndstage_time >= 4000)
 161   4                     {
 162   5                     sensor_trigger_count = 0;
 163   5                     sensor_2ndstage_count = 0;
 164   5                     sensor_1ststage_count = 0;
 165   5                     sensor_2ndstage_time = 0;
 166   5                     }
 167   4                  }
 168   3               break;
 169   3               
 170   3               case 2:
 171   3                  {
 172   4                  if(++sensor_3rdstage_interval >= 700)
 173   4                     {
 174   5                     if(sensor_detect == 0)
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 4   

 175   5                        {
 176   6                        sensor_3rdstage_count++;
 177   6                        if(sensor_3rdstage_count >= 3)
 178   6                           {
 179   7                           sensor_3rdstage_count = 0;
 180   7                           sensor_3rdstage_interval = 0;
 181   7                           sensor_3rdstage_effcount++;
 182   7                           }
 183   6                        }
 184   5                     else
 185   5                        {
 186   6                        sensor_3rdstage_count = 0;
 187   6                        }
 188   5                     }
 189   4                  
 190   4                  sensor_3rdstage_time++;
 191   4                  if((sensor_3rdstage_time <= 4000)&&(sensor_3rdstage_effcount >= 3))
 192   4                     {
 193   5                     if(raised_fell_flag == 0)
 194   5                        {
 195   6                        host_stolen_alarm1_EN = 1;
 196   6                        }
 197   5                     }
 198   4                  
 199   4                  if((sensor_3rdstage_time <= 6000)&&(sensor_3rdstage_effcount >= 4))
 200   4                     {
 201   5                     if(raised_fell_flag == 0)
 202   5                        {
 203   6                        host_stolen_alarm2_EN = 1;                
 204   6                        }
 205   5                     }
 206   4                  if(sensor_3rdstage_time >8000)
 207   4                     {
 208   5                     sensor_trigger_count = 0;
 209   5                     sensor_1ststage_count = 0;
 210   5                     sensor_2ndstage_count = 0;
 211   5                     sensor_2ndstage_time = 0;
 212   5                     sensor_3rdstage_time = 0;
 213   5                     sensor_3rdstage_interval = 800;
 214   5                     sensor_3rdstage_count = 0;
 215   5                     sensor_3rdstage_effcount = 0;
 216   5                     }
 217   4                  }
 218   3               break;
 219   3               }
 220   2            }
 221   1         
 222   1         
 223   1         if((host_touch_speech_EN == 1)&&(host_touch_speech_count < 1))
 224   1            {
 225   2            if(raised_fell_flag == 0)
 226   2               {
 227   3               host_touch_speech();
 228   3               }
 229   2               
 230   2            if(++host_touch_speech_count >= 1)
 231   2               {
 232   3               host_touch_speech_count = 0;
 233   3               host_touch_speech_EN = 0;
 234   3               }
 235   2            }
 236   1         
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 5   

 237   1         if((host_2ndtouch_speech_EN == 1)&&(host_2ndtouch_speech_count < 1))
 238   1            {
 239   2            if(raised_fell_flag == 0)
 240   2               {
 241   3               host_2ndtouch_speech();
 242   3               }
 243   2               
 244   2            if(++host_2ndtouch_speech_count >= 1)
 245   2               {
 246   3               host_2ndtouch_speech_count = 0;
 247   3               host_2ndtouch_speech_EN = 0;
 248   3               }
 249   2            }
 250   1         
 251   1      
 252   1      // ¼ì²âµ¹µØºÍÌ§Æð¼ì²âµÄ´úÂë
 253   1         if(position_sensor_EN==1)        //¿ªÆôÁËÌ§Æðµ¹µØ¼ì²â
 254   1         {
 255   2            if(raised_sensor_detect==0)   //ËµÃ÷ÓÐÌ§ÆðÐÅºÅ²¢ÇÒÊÇµÚÒ»´Î£¬¿ªÊ¼¼ÆÊ±
 256   2            {
 257   3               raise_wire_time++;
 258   3               if(raise_wire_time==10) //ËµÃ÷ÒÑ¾­´óÓÚ0.5S
 259   3               {
 260   4                  raised_flag=1;          //ÖÃÌ§Æð±êÖ¾
 261   4                  fell_flag=0;
 262   4                  raised_fell_flag = 1;
 263   4               }     
 264   3            }
 265   2            else
 266   2            {
 267   3               raised_flag=0;
 268   3               raised_alarm_count=0;
 269   3               raise_wire_time=0;
 270   3               raised_fell_flag = 0;
 271   3            }
 272   2      
 273   2            if(fell_sensor_detect==0)
 274   2            {
 275   3               fell_wire_time++;
 276   3               if(fell_wire_time==10)     //ËµÃ÷ÒÑ¾­´óÓÚ0.5s
 277   3               {
 278   4                  fell_flag=1;            //ÖÃÌ§Æð±êÖ¾
 279   4                  raised_flag=0;
 280   4                  raised_fell_flag = 1;
 281   4               }     
 282   3            }
 283   2            else
 284   2            {
 285   3               fell_flag=0;
 286   3               fell_alarm_count=0;
 287   3               fell_wire_time=0;
 288   3               raised_fell_flag = 0;
 289   3            }
 290   2         }
 291   1         
 292   1         if(raised_fell_flag == 1)
 293   1            {
 294   2            if(++raised_fell_number >= 5000)
 295   2               {
 296   3               raised_fell_flag = 0;
 297   3               raised_fell_number = 0;
 298   3               }
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 6   

 299   2            }
 300   1      }
 301          
 302          
 303          /*------------------------------------------------------------------
 304             timerT1()
 305             ¶¨Ê±Æ÷1Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
 306          --------------------------------------------------------------------*/
 307          
 308          void timerT1() interrupt interrupt_timer_1_overflow
 309          {
 310   1      
 311   1         TH1 = timer1_8H;              //ÖØ×°ÔØ
 312   1         TL1 = timer1_8L;
 313   1         
 314   1         if(P11==0)//Õý³£Çé¿öÎª¸ßµçÆ½,ÓÐµÍµçÆ½ËµÃ÷ÓÐÐÅºÅ
 315   1         {
 316   2            receive_LV_count++;
 317   2            receive_wire_flag=0;
 318   2            if(receive_LV_count==80)//µÍµçÆ½³ÖÐøµÄ×î´óÊ±¼ä  
 319   2            {
 320   3               receive_LV_count=0;
 321   3            }
 322   2         }
 323   1         else//Îª¸ßµçÆ½ÁË
 324   1         {
 325   2            if(receive_wire_flag==0)//ËµÃ÷ÓÐÒ»¸öµÍµçÆ½
 326   2            {
 327   3               receive_wire_flag=1;
 328   3      
 329   3               if((receive_LV_count>35)&&(receive_LV_count<=50))  //µÍµçÆ½³ÖÐøµÄÊ±¼äÐ¡ÓÚ10ms£¬ÔòÎª0
 330   3               {
 331   4                  one_receive_byte<<=1;
 332   4                  one_receive_byte &= 0xfe;
 333   4                  one_receive_byte_count++;
 334   4                  receive_HV_count=0;
 335   4               }
 336   3               else if((receive_LV_count>50))//µÍµçÆ½³ÖÐøµÄÊ±¼ä´óÓÚ4.5ms£¬ÔòÎª1
 337   3               {
 338   4                  one_receive_byte<<=1;
 339   4                  one_receive_byte |= 0x01;
 340   4                  one_receive_byte_count++;
 341   4                  receive_HV_count=0;
 342   4               }
 343   3               else
 344   3               {
 345   4                  receive_HV_count++;  
 346   4               }
 347   3      
 348   3               receive_LV_count=0;
 349   3            }
 350   2      
 351   2            else
 352   2            {
 353   3               receive_HV_count++;
 354   3               if(receive_HV_count>=60)
 355   3               {
 356   4                  one_receive_byte_count=0;
 357   4                  receive_wire_flag=1;
 358   4                  data_count=0;
 359   4               }     
 360   3            }
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 7   

 361   2         }
 362   1      
 363   1         if(one_receive_byte_count==8)//ËµÃ÷Ò»¸ö×Ö½ÚµÄÊý¾ÝÒÑ¾­½ÓÊÜÍêÈ«
 364   1         {
 365   2            one_receive_byte_count=0;
 366   2            received_data_buffer[data_count]=one_receive_byte;
 367   2            if(data_count==0&&received_data_buffer[0] == CmdHead)
 368   2            {
 369   3               data_count=1;
 370   3            }
 371   2            else if(data_count==1&&received_data_buffer[1]==MyAddress)
 372   2            {
 373   3               data_count=2;
 374   3            }
 375   2            else if(data_count==2)
 376   2            {
 377   3               receive_data_finished_flag=1;
 378   3               data_count=0;
 379   3            }
 380   2            else 
 381   2            {
 382   3               data_count=0;
 383   3            }
 384   2         }
 385   1      
 386   1         if(receive_data_finished_flag==1)
 387   1         {
 388   2            receive_data_finished_flag=0;
 389   2            switch(received_data_buffer[2])     //¶ÔÊý¾ÝÖ¡ÀïµÄÃüÁî½øÐÐ´¦Àí
 390   2            {
 391   3               case ComMode_1:      //¸½»ú·¢ËÍ¹ýÀ´µÄÖ»ÓÃÄ£Ê½1£¬ËµÃ÷ÏÖÔÚÊÇÕý³£µÄ£¬Êý¾Ý²¿·ÖÎªÊý×éµÄµÚÒ»ºÍµÚ¶þ¸ö×Ö½Ú£¬ÎªÃÜÂ
             -ë±íÄÚµÄÕâ¸ö±àÂëµÄ¿ªÊ¼×Ö½ÚµÄÄÇ¸öµØÖ·£¬È»ºóÌî³äÊý¾ÝÖ¡£¬°ÑÃÜÂë±íµÄÊý¾Ý·¢ËÍ³öÈ¥
 392   3               {
 393   4                  ComMode_1_Data();    //Ïò¸½»ú·¢ËÍ±àÂë3
 394   4      
 395   4                  slave_nearby_speech_EN=1;     //±àÂë1ºó±¨Ò»¾äÓïÒô
 396   4      
 397   4                  sensor_EN=0;   //ÈýÖá´«¸ÐÆ÷
 398   4                  position_sensor_EN=0;      //¹Øµ¹µØ¡¢Ì§Æð¼ì²â
 399   4                  fell_flag=0;  
 400   4                  raised_flag=0;
 401   4                  magnet_CW_EN=1;         //´ò¿ªµç´ÅÌú
 402   4                  
 403   4                  sensor_trigger_count = 0;
 404   4                  sensor_1ststage_count = 0;
 405   4                  sensor_2ndstage_count = 0;
 406   4                  sensor_2ndstage_time = 0;
 407   4                  sensor_3rdstage_time = 0;
 408   4                  sensor_3rdstage_interval = 0;
 409   4                  sensor_3rdstage_count = 0;
 410   4                  sensor_3rdstage_effcount = 0;
 411   4                  stolen_alarm_flag = 0;
 412   4                  host_stolen_alarm1_EN = 0;
 413   4                  host_stolen_alarm1_count = 0;
 414   4                  host_stolen_alarm2_EN = 0;
 415   4                  host_stolen_alarm2_count = 0;
 416   4                  
 417   4                  leave_count=0; 
 418   4                  if(slave_away==1)
 419   4                  {
 420   5                     slave_away=0;
 421   5                  }
C51 COMPILER V9.51   TIMER                                                                 12/04/2013 11:18:56 PAGE 8   

 422   4               }
 423   3               break;
 424   3            }
 425   2         }
 426   1      }
 427          
 428          /*--------------------------------------------------
 429             InitTimer()
 430             
 431             ³õÊ¼»¯¶¨Ê±Æ÷T0ºÍT1
 432          ---------------------------------------------------*/
 433          
 434          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
 435             {
 436   1         tLong Inc_T0, Inc_T1;
 437   1         tWord timer0_16, timer1_16;
 438   1         
 439   1         //¼ÆËãTimer0µÄ¼Ä´æÆ÷Öµ
 440   1         Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
 441   1         timer0_16 = (tWord) (65536UL - Inc_T0);
 442   1         timer0_8H = (tByte) (timer0_16 / 256);
 443   1         timer0_8L = (tByte) (timer0_16 % 256);
 444   1         
 445   1         //¼ÆËãTimer1µÄ¼Ä´æÆ÷Öµ
 446   1         Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
 447   1         timer1_16 = (tWord) (65536UL - Inc_T1);
 448   1         timer1_8H = (tByte) (timer1_16 / 256);
 449   1         timer1_8L = (tByte) (timer1_16 % 256);
 450   1         
 451   1         TMOD = 0x11;
 452   1         
 453   1         TH0 = timer0_8H;
 454   1         TL0 = timer0_8L;
 455   1         TH1 = timer1_8H;
 456   1         TL1 = timer1_8L;
 457   1      
 458   1         ET0 = 1;
 459   1         TR0 = 1;
 460   1         ET1 = 1;
 461   1         TR1 = 1;
 462   1         PT1 = 1;       
 463   1         EA = 1;
 464   1         }
 465             
 466          /*---------------------------------------------------
 467             end of file
 468          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    970    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     18    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
