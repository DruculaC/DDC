C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Timer.c BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             Timer.c (v1.00)
   3             
   4             Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "voice.h"
  13          
  14          // ------ Public variable declarations -----------------------------
  15          bit stolen_alarm_flag = 0;    //Ö÷»ú±»µÁ±¨¾¯±êÖ¾£¬1µÄÊ±ºò±íÊ¾´¥·¢    
  16          bit host_stolen_speech_EN = 0;      //Ö÷»ú±»µÁÓïÒôÊ¹ÄÜ£¬1µÄÊ±ºòÔÚmainÖÐÓïÒôÌáÊ¾
  17          bit battery_check=0;    //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎµçÁ¿×ª»»£¬Ö´ÐÐÍêºó£¬½«ÆäÖÃ0
  18          bit position_sensor_EN=0;        //Î»ÖÃ´«¸ÐÆ÷£¬¼´µ¹µØÌ§Æð´«¸ÐÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ÐÆ÷
  19          bit slave_away_speech_EN=0;      //ÅÐ¶Ï¸½»úÀë¿ªºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  20          bit magnet_CW_EN = 0;               //µç´ÅÌúË³Ê±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  21          bit magnet_ACW_EN=0;                //µç´ÅÌúÄæÊ±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  22          bit comm_whole_control=0;           //Í¨ÐÅ×Ü¿ª¹Ø£¬0¹Ø±ÕÍ¨ÐÅ£¬1´ò¿ªÍ¨ÐÅ
  23          tWord host_stolen_speech_count=0;   //ÅÐ¶ÏÖ÷»ú±»µÁºó£¬ÓïÒôÌáÊ¾µÄ´ÎÊý
  24          bit slave_nearby_speech_EN=0;       //ÅÐ¶Ï¸½½ü¿¿½üºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  25          
  26          // ------ Private variable definitions -----------------------------
  27          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;  //¶¨Ê±Æ÷0ºÍ1µÄ¶¨Ê±Êý¾Ý
  28          
  29          tByte host_touch_speech_count=0;
  30          tByte sensor_trigger_count=0; //´«¸ÐÆ÷´¥·¢¼ÆÊý
  31          tByte host_touched_flag=0;       //Ö÷»ú±»´¥ÅöºóÖÃ1£¬½øÐÐºóÃæµÄ´«¸ÐÆ÷ÅÐ¶Ï
  32          tWord sensor_2ndstage_time=0;    //´«¸ÐÆ÷µÚÒ»½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊý
  33          tByte sensor_1ststage_count=0;   //´«¸ÐÆ÷µÚÒ»½×¶ÎÅÐ¶ÏµÍµçÆ½µÄ¼ÆÊý
  34          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æðºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  35          bit raised_flag=0;               //ÅÐ¶ÏÖ÷»ú±»Ì§Æðºó£¬ÖÃ1
  36          tByte fell_alarm_count=0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  37          bit fell_flag=0;                 //ÅÐ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  38          tWord timer0_count=0;            //timer0Ã¿´ÎÒç³öºó¼Ó1£¬±íÊ¾ÓÃtimer0¼ÆÊ±
  39          tByte slave_away=0;              //Ä£Ê½Ñ¡ÔñÎ»£¬1ÔòÓÃÄ£Ê½1,2ÔòÓÃÄ£Ê½2,3ÔòÎªÄ£Ê½3
  40          tByte leave_count=0;             //¸½»úÀë¿ªÊ±µÄ¼ÆÊý£¬Ö»Òª¸½»ú3sÓ¦´ðÕýÈ·£¬¾ÍÇå0   
  41          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};     //½ÓÊÕÊý¾Ý»º´æ
  42          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  43          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  44          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  45          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  46          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  47          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  48          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  49          tByte fell_wire_time=0;          //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  50          tByte raise_wire_time=0;         //Ì§Æð¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  51          tByte sensor_2ndstage_LV_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  52          
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 2   

  53          
  54          /*------------------------------------------------------------------
  55             timerT0()
  56             ¶¨Ê±Æ÷0Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  57          --------------------------------------------------------------------*/
  58          
  59          void timer0() interrupt interrupt_timer_0_overflow //×÷ÎªÕû¸öÏµÍ³×Ô¼ºµÄÊ±ÖÓ
  60          {
  61   1         TH0 = timer0_8H;
  62   1         TL0 = timer0_8L;
  63   1         
  64   1         timer0_count++;
  65   1      
  66   1         if(timer0_count>=2000)//´®¿ÚÃ¿3s½ÓÊÜÒ»´ÎµÄÊý¾ÝµÄÊ±¼ä±êÖ¾
  67   1         {
  68   2            if(comm_whole_control==1)//ËµÃ÷¿ªÆôÁËÍ¨ÐÅ
  69   2            {
  70   3               leave_count++;
  71   3      
  72   3               if((leave_count>=4&&slave_away==0))
  73   3               {
  74   4                  leave_count=5;
  75   4                  
  76   4                  if(key_rotate==0)
  77   4                     {
  78   5                        magnet_CW_EN=1;         //µç´ÅÌúËøÉÏ
  79   5                        slave_away_speech_EN=1;    //±¨¸½»úÀë¿ªÓïÒô
  80   5                        position_sensor_EN=1;      //¿ªÆôµ¹µØ¡¢Ì§Æð±êÖ¾
  81   5                        slave_away=1;
  82   5                     }
  83   4      
  84   4                  sensor_trigger_count=0;
  85   4                  sensor_1ststage_count=0;
  86   4                     
  87   4               }
  88   3            }
  89   2            timer0_count=0;
  90   2            
  91   2            battery_check=1;     
  92   2            
  93   2            if((fell_flag==1)&&(fell_alarm_count<5))  //µ¹µØºó×öÏàÓ¦µÄ¶¯×÷
  94   2            {
  95   3               ComMode_5_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
  96   3               fell_alarm_count++;
  97   3            }
  98   2            if((raised_flag==1)&&(raised_alarm_count<5))    //Ì§Æðºó×öÏàÓ¦¶¯×÷
  99   2            {
 100   3      //       sendcomm4=1;
 101   3               ComMode_4_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
 102   3               raised_alarm_count++;
 103   3            }
 104   2         }
 105   1      
 106   1         if(sensor_EN==1)  //¼ì²âÈýÖá´«¸ÐÆ÷ÊÇ·ñ´ò¿ª£¬²¢ÇÒ»¹Ã»ÓÐ±¨¾¯
 107   1         {
 108   2            if((sensor_detect==0)&&(stolen_alarm_flag==0))
 109   2            {
 110   3               sensor_1ststage_count++;
 111   3               if(sensor_1ststage_count>=2)            //Ã¿1ms¼ì²âÒ»´Î¸ßµçÆ½£¬Èç¹û´óÓÚÁË6msµÄ¸ß¶¨Æ½£¬ËµÃ÷ÓÐÈËÅöÁËÒ»ÏÂ
 112   3               {
 113   4                  sensor_1ststage_count=0;
 114   4                  sensor_trigger_count++;
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 3   

 115   4                  host_touch_speech_count=0;
 116   4                  host_touched_flag=1;
 117   4               }
 118   3            }
 119   2            else
 120   2            {
 121   3               sensor_1ststage_count=0;
 122   3            }
 123   2            
 124   2            if(host_touched_flag==1)
 125   2            {
 126   3               sensor_2ndstage_time++;
 127   3               if(sensor_2ndstage_time>=6000)
 128   3               {
 129   4                  sensor_trigger_count=0;
 130   4                  sensor_1ststage_count=0;
 131   4                  sensor_2ndstage_time=0;
 132   4                  host_touched_flag=0;
 133   4                  host_touch_speech_count=0;
 134   4               }
 135   3            }
 136   2         }
 137   1      
 138   1         if(sensor_trigger_count==1)
 139   1         {
 140   2            if((host_touch_speech_count<1)&&(host_stolen_speech_EN!=1))
 141   2            {
 142   3               if((fell_sensor_detect==1)&&(raised_sensor_detect==1))
 143   3               {
 144   4                  host_touch_speech();
 145   4                  host_touch_speech_count++;
 146   4               }
 147   3            }
 148   2         }
 149   1         else
 150   1         {
 151   2            if(sensor_2ndstage_time>=300)
 152   2            {
 153   3               if(sensor_detect==0)
 154   3               {
 155   4                  sensor_2ndstage_LV_time++;
 156   4                  if(sensor_2ndstage_LV_time>=2)   
 157   4                  {
 158   5                     host_stolen_speech_EN=1;
 159   5                     host_stolen_speech_count=0;
 160   5                     stolen_alarm_flag=1;
 161   5                     sensor_2ndstage_LV_time=0; 
 162   5                  }
 163   4               }
 164   3               else
 165   3               {
 166   4                  sensor_2ndstage_LV_time=0;
 167   4               }
 168   3            }                  
 169   2         }
 170   1      
 171   1      // ¼ì²âµ¹µØºÍÌ§Æð¼ì²âµÄ´úÂë
 172   1         if(position_sensor_EN==1)//¿ªÆôÁËÌ§Æðµ¹µØ¼ì²â
 173   1         {
 174   2            if(raised_sensor_detect==0)//ËµÃ÷ÓÐÌ§ÆðÐÅºÅ²¢ÇÒÊÇµÚÒ»´Î£¬¿ªÊ¼¼ÆÊ±
 175   2            {
 176   3               raise_wire_time++;
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 4   

 177   3               if(raise_wire_time==10)//ËµÃ÷ÒÑ¾­´óÓÚ0.5S
 178   3               {
 179   4                  raised_flag=1;//ÖÃÌ§Æð±êÖ¾
 180   4                  fell_flag=0;
 181   4               }     
 182   3            }
 183   2            else
 184   2            {
 185   3               raised_flag=0;
 186   3               raised_alarm_count=0;
 187   3               raise_wire_time=0;
 188   3            }
 189   2      
 190   2            if(fell_sensor_detect==0)
 191   2            {
 192   3               fell_wire_time++;
 193   3               if(fell_wire_time==10)//ËµÃ÷ÒÑ¾­´óÓÚ0.5S
 194   3               {
 195   4                  fell_flag=1;//ÖÃÌ§Æð±êÖ¾
 196   4                  raised_flag=0;
 197   4               }     
 198   3            }
 199   2            else
 200   2            {
 201   3               fell_flag=0;
 202   3               fell_alarm_count=0;
 203   3               fell_wire_time=0;
 204   3            }
 205   2         }
 206   1      }
 207          
 208          
 209          /*------------------------------------------------------------------
 210             timerT1()
 211             ¶¨Ê±Æ÷1Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
 212          --------------------------------------------------------------------*/
 213          
 214          void timerT1() interrupt interrupt_timer_1_overflow
 215          {
 216   1      
 217   1         TH1 = timer1_8H;              //ÖØ×°ÔØ
 218   1         TL1 = timer1_8L;
 219   1         
 220   1         if(P11==0)//Õý³£Çé¿öÎª¸ßµçÆ½,ÓÐµÍµçÆ½ËµÃ÷ÓÐÐÅºÅ
 221   1         {
 222   2            receive_LV_count++;
 223   2            receive_wire_flag=0;
 224   2            if(receive_LV_count==80)//µÍµçÆ½³ÖÐøµÄ×î´óÊ±¼ä  
 225   2            {
 226   3               receive_LV_count=0;
 227   3            }
 228   2         }
 229   1         else//Îª¸ßµçÆ½ÁË
 230   1         {
 231   2            if(receive_wire_flag==0)//ËµÃ÷ÓÐÒ»¸öµÍµçÆ½
 232   2            {
 233   3               receive_wire_flag=1;
 234   3      
 235   3               if((receive_LV_count>35)&&(receive_LV_count<=50))  //µÍµçÆ½³ÖÐøµÄÊ±¼äÐ¡ÓÚ10ms£¬ÔòÎª0
 236   3               {
 237   4                  one_receive_byte<<=1;
 238   4                  one_receive_byte &= 0xfe;
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 5   

 239   4                  one_receive_byte_count++;
 240   4                  receive_HV_count=0;
 241   4               }
 242   3               else if((receive_LV_count>50))//µÍµçÆ½³ÖÐøµÄÊ±¼ä´óÓÚ4.5ms£¬ÔòÎª1
 243   3               {
 244   4                  one_receive_byte<<=1;
 245   4                  one_receive_byte |= 0x01;
 246   4                  one_receive_byte_count++;
 247   4                  receive_HV_count=0;
 248   4               }
 249   3               else
 250   3               {
 251   4                  receive_HV_count++;  
 252   4               }
 253   3      
 254   3               receive_LV_count=0;
 255   3            }
 256   2      
 257   2            else
 258   2            {
 259   3               receive_HV_count++;
 260   3               if(receive_HV_count>=60)
 261   3               {
 262   4                  one_receive_byte_count=0;
 263   4                  receive_wire_flag=1;
 264   4                  data_count=0;
 265   4               }     
 266   3            }
 267   2         }
 268   1      
 269   1         if(one_receive_byte_count==8)//ËµÃ÷Ò»¸ö×Ö½ÚµÄÊý¾ÝÒÑ¾­½ÓÊÜÍêÈ«
 270   1         {
 271   2            one_receive_byte_count=0;
 272   2            received_data_buffer[data_count]=one_receive_byte;
 273   2            if(data_count==0&&received_data_buffer[0]==CmdHead)
 274   2            {
 275   3               data_count=1;
 276   3            }
 277   2            else if(data_count==1&&received_data_buffer[1]==MyAddress)
 278   2            {
 279   3               data_count=2;
 280   3            }
 281   2            else if(data_count==2)
 282   2            {
 283   3               receive_data_finished_flag=1;
 284   3               data_count=0;
 285   3            }
 286   2            else 
 287   2            {
 288   3               data_count=0;
 289   3            }
 290   2         }
 291   1      
 292   1         if(receive_data_finished_flag==1)
 293   1         {
 294   2            receive_data_finished_flag=0;
 295   2            switch(received_data_buffer[2])     //¶ÔÊý¾ÝÖ¡ÀïµÄÃüÁî½øÐÐ´¦Àí
 296   2            {
 297   3               case ComMode_1:      //¸½»ú·¢ËÍ¹ýÀ´µÄÖ»ÓÃÄ£Ê½1£¬ËµÃ÷ÏÖÔÚÊÇÕý³£µÄ£¬Êý¾Ý²¿·ÖÎªÊý×éµÄµÚÒ»ºÍµÚ¶þ¸ö×Ö½Ú£¬ÎªÃÜÂ
             -ë±íÄÚµÄÕâ¸ö±àÂëµÄ¿ªÊ¼×Ö½ÚµÄÄÇ¸öµØÖ·£¬È»ºóÌî³äÊý¾ÝÖ¡£¬°ÑÃÜÂë±íµÄÊý¾Ý·¢ËÍ³öÈ¥
 298   3               {
 299   4                  stolen_alarm_flag=0;
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 6   

 300   4                  
 301   4                  ComMode_1_Data();    //Ïò¸½»ú·¢ËÍ±àÂë3
 302   4      
 303   4                  slave_nearby_speech_EN=1;     //±àÂë1ºó±¨Ò»¾äÓïÒô
 304   4      
 305   4      
 306   4                  sensor_EN=0;   //ÈýÖá´«¸ÐÆ÷
 307   4                  position_sensor_EN=0;      //¹Øµ¹µØ¡¢Ì§Æð¼ì²â
 308   4                  fell_flag=0;  
 309   4                  raised_flag=0;
 310   4                  magnet_ACW_EN=1;        //´ò¿ªµç´ÅÌú
 311   4                  
 312   4                  sensor_trigger_count=0;
 313   4                  sensor_1ststage_count=0;
 314   4                  sensor_2ndstage_time=0;
 315   4                  host_touched_flag=0;
 316   4                  host_stolen_speech_EN=0;
 317   4                  host_stolen_speech_count=0;
 318   4      
 319   4                  leave_count=0; 
 320   4                  if(slave_away==1)
 321   4                  {
 322   5                     slave_away=0;
 323   5                  }
 324   4               }
 325   3               break;
 326   3            }
 327   2         }
 328   1      }
 329          
 330          /*--------------------------------------------------
 331             InitTimer()
 332             
 333             ³õÊ¼»¯¶¨Ê±Æ÷T0ºÍT1
 334          ---------------------------------------------------*/
 335          
 336          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
 337             {
 338   1         tLong Inc_T0, Inc_T1;
 339   1         tWord timer0_16, timer1_16;
 340   1         
 341   1         //¼ÆËãTimer0µÄ¼Ä´æÆ÷Öµ
 342   1         Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
 343   1         timer0_16 = (tWord) (65536UL - Inc_T0);
 344   1         timer0_8H = (tByte) (timer0_16 / 256);
 345   1         timer0_8L = (tByte) (timer0_16 % 256);
 346   1         
 347   1         //¼ÆËãTimer1µÄ¼Ä´æÆ÷Öµ
 348   1         Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
 349   1         timer1_16 = (tWord) (65536UL - Inc_T1);
 350   1         timer1_8H = (tByte) (timer1_16 / 256);
 351   1         timer1_8L = (tByte) (timer1_16 % 256);
 352   1         
 353   1         TMOD = 0x11;
 354   1         
 355   1         TH0 = timer0_8H;
 356   1         TL0 = timer0_8L;
 357   1         TH1 = timer1_8H;
 358   1         TL1 = timer1_8L;
 359   1      
 360   1         ET0 = 1;
 361   1         TR0 = 1;
C51 COMPILER V9.51   TIMER                                                                 11/26/2013 12:20:38 PAGE 7   

 362   1         ET1 = 1;
 363   1         TR1 = 1;
 364   1         PT1 = 1;       
 365   1         EA = 1;
 366   1         }
 367             
 368          /*---------------------------------------------------
 369             end of file
 370          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    731    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     13    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
