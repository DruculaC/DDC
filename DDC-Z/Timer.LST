C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Timer.c BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             Timer.c (v1.00)
   3             
   4             Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "voice.h"
  13          
  14          // ------ Public variable declarations -----------------------------
  15          bit stolen_alarm_flag = 0;    //Ö÷»ú±»µÁ±¨¾¯±êÖ¾£¬1µÄÊ±ºò±íÊ¾´¥·¢    
  16          bit host_stolen_speech_EN = 0;      //Ö÷»ú±»µÁÓïÒôÊ¹ÄÜ£¬1µÄÊ±ºòÔÚmainÖÐÓïÒôÌáÊ¾
  17          bit battery_check=0;    //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎµçÁ¿×ª»»£¬Ö´ÐÐÍêºó£¬½«ÆäÖÃ0
  18          bit position_sensor_EN=0;        //Î»ÖÃ´«¸ÐÆ÷£¬¼´µ¹µØÌ§Æð´«¸ÐÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ÐÆ÷
  19          bit slave_away_speech_EN=0;      //ÅÐ¶Ï¸½»úÀë¿ªºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  20          bit magnet_CW_EN = 0;               //µç´ÅÌúË³Ê±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  21          bit magnet_ACW_EN=0;                //µç´ÅÌúÄæÊ±Õë×ª¶¯Ê¹ÄÜ£¬×ª¶¯Ò»´Îºó¸´Î»Îª0
  22          bit comm_whole_control=0;           //Í¨ÐÅ×Ü¿ª¹Ø£¬0¹Ø±ÕÍ¨ÐÅ£¬1´ò¿ªÍ¨ÐÅ
  23          tWord host_stolen_speech_count=0;   //ÅÐ¶ÏÖ÷»ú±»µÁºó£¬ÓïÒôÌáÊ¾µÄ´ÎÊý
  24          bit slave_nearby_speech_EN=0;       //ÅÐ¶Ï¸½½ü¿¿½üºó£¬ÓïÒôÌáÊ¾£¬ÔÚmainÀïÃæ²Ù×÷
  25          bit host_stolen_alarm1_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒôÊ¹ÄÜ
  26          bit host_stolen_alarm2_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒôÊ¹ÄÜ
  27          tByte host_stolen_alarm1_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒô´ÎÊý
  28          tByte host_stolen_alarm2_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒô´ÎÊý
  29          
  30          // ------ Private variable definitions -----------------------------
  31          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;  //¶¨Ê±Æ÷0ºÍ1µÄ¶¨Ê±Êý¾Ý
  32          
  33          tByte host_touch_speech_count=0;
  34          tByte sensor_trigger_count=0; //´«¸ÐÆ÷´¥·¢¼ÆÊý
  35          tByte host_touched_flag=0;       //Ö÷»ú±»´¥ÅöºóÖÃ1£¬½øÐÐºóÃæµÄ´«¸ÐÆ÷ÅÐ¶Ï
  36          tWord sensor_2ndstage_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊý
  37          tByte sensor_1ststage_count=0;   //´«¸ÐÆ÷µÚÒ»½×¶ÎÅÐ¶ÏµÍµçÆ½µÄ¼ÆÊý
  38          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æðºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  39          bit raised_flag=0;               //ÅÐ¶ÏÖ÷»ú±»Ì§Æðºó£¬ÖÃ1
  40          tByte fell_alarm_count=0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  41          bit fell_flag=0;                 //ÅÐ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  42          tWord timer0_count=0;            //timer0Ã¿´ÎÒç³öºó¼Ó1£¬±íÊ¾ÓÃtimer0¼ÆÊ±
  43          tByte slave_away=0;              //Ä£Ê½Ñ¡ÔñÎ»£¬1ÔòÓÃÄ£Ê½1,2ÔòÓÃÄ£Ê½2,3ÔòÎªÄ£Ê½3
  44          tByte leave_count=0;             //¸½»úÀë¿ªÊ±µÄ¼ÆÊý£¬Ö»Òª¸½»ú3sÓ¦´ðÕýÈ·£¬¾ÍÇå0   
  45          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};     //½ÓÊÕÊý¾Ý»º´æ
  46          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  47          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  48          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  49          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  50          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  51          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  52          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 2   

  53          tByte fell_wire_time=0;          //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  54          tByte raise_wire_time=0;         //Ì§Æð¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  55          tByte sensor_2ndstage_LV_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  56          tByte sensor_2ndstage_count = 0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  57          tByte host_2ndtouch_speech_count = 0;     //Ö÷»ú±»µÚ¶þ´Î´¥Åöºó£¬ÓïÒôÌáÊ¾µÄ´ÎÊý
  58          tWord sensor_3rdstage_time = 0;        //´«¸ÐÆ÷½øÈëµÚÈý½×¶ÎµÄÊ±¼ä£¬
  59          tByte sensor_3rdstage_effcount = 0;    //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬ÓÐÐ§´¥Åö´ÎÊýµÄ¼ÆÊý
  60          tByte sensor_3rdstage_count = 0;       //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬µÍµçÆ½µÄ¼ÆÊý
  61          tWord sensor_3rdstage_interval = 0;    //´«¸ÐÆ÷ÔÚµÚÈý½×¶ÎÖÐ£¬Ã¿´ÎÓÐÐ§µÍµçÆ½¼ÆÊýÖ®¼äµÄÊ±¼ä¼ä¸ô¡£ÔÚÕâÆÚ¼äµÄµÍµ
             -çÆ½²»ÈÏÎªÓÐÐ§¡£
  62          bit host_touch_speech_EN = 0;          //µÚÒ»´Î´¥ÅöºóÓïÒôÊ¹ÄÜ
  63          bit host_2ndtouch_speech_EN = 0;       //µÚ¶þ´Î´¥ÅöºóÓïÒôÊ¹ÄÜ
  64          bit raised_fell_flag = 0;              //µ¹µØ»òÕßÌ§Æð´¥·¢ºó£¬´Ë±êÖ¾Î»ÖÃ1
  65          tWord raised_fell_number = 0;          //µ¹µØ»òÕßÌ§Æð³ö·¢ºó£¬¼ÆÊý£¬µ½´ïÒ»¶¨ÊýÖµºó£¬½«ÆäÓë±êÖ¾Î»Ò»ÆðÇåÁã¡£
  66          bit raised_fell_once_flag = 0;         //raised_fell_flagÊÇ·ñÔø¾­±êÖ¾¹ý£¬Èç¹û±êÖ¾¹ýÔòÖÃ1.È»ºóÖ÷»ú±»»Ö¸´µ¹µØ»òÕß»
             -Ö¸´Ì§ÆðÊ±£¬´Ë±êÖ¾Î»¸´Î»¡£
  67          
  68          /*------------------------------------------------------------------
  69             timerT0()
  70             ¶¨Ê±Æ÷0Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  71          --------------------------------------------------------------------*/
  72          
  73          void timer0() interrupt interrupt_timer_0_overflow //×÷ÎªÕû¸öÏµÍ³×Ô¼ºµÄÊ±ÖÓ
  74          {
  75   1         TH0 = timer0_8H;
  76   1         TL0 = timer0_8L;
  77   1         
  78   1         timer0_count++;
  79   1      
  80   1         if(timer0_count>=2000)//´®¿ÚÃ¿3s½ÓÊÜÒ»´ÎµÄÊý¾ÝµÄÊ±¼ä±êÖ¾
  81   1         {
  82   2            if(comm_whole_control==1)//ËµÃ÷¿ªÆôÁËÍ¨ÐÅ
  83   2            {
  84   3               leave_count++;
  85   3      
  86   3               if((leave_count>=4&&slave_away==0))
  87   3               {
  88   4                  leave_count=5;
  89   4                  
  90   4                  if(key_rotate == 0)
  91   4                     {
  92   5                        magnet_ACW_EN=1;        //µç´ÅÌúËøÉÏ
  93   5                        slave_away_speech_EN=1;    //±¨¸½»úÀë¿ªÓïÒô
  94   5                        position_sensor_EN=1;      //¿ªÆôµ¹µØ¡¢Ì§Æð±êÖ¾
  95   5                        slave_away=1;
  96   5                     }
  97   4      
  98   4                  sensor_trigger_count=0;
  99   4                  sensor_1ststage_count=0;
 100   4                     
 101   4               }
 102   3            }
 103   2            timer0_count=0;
 104   2            
 105   2            battery_check=1;     
 106   2            
 107   2            if((fell_flag==1)&&(fell_alarm_count<5))  //µ¹µØºó×öÏàÓ¦µÄ¶¯×÷
 108   2            {
 109   3               ComMode_5_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
 110   3               fell_alarm_count++;
 111   3            }
 112   2            if((raised_flag==1)&&(raised_alarm_count<5))    //Ì§Æðºó×öÏàÓ¦¶¯×÷
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 3   

 113   2            {
 114   3               ComMode_4_Data(); //Ïò¸½»ú·¢ËÍ±àÂë3
 115   3               raised_alarm_count++;
 116   3            }
 117   2         }
 118   1      
 119   1         if(raised_fell_flag == 0)
 120   1            {
 121   2            if(sensor_EN==1)     //¼ì²âÈýÖá´«¸ÐÆ÷ÊÇ·ñ´ò¿ª
 122   2               {
 123   3               switch(sensor_trigger_count)
 124   3                  {
 125   4                  case 0:
 126   4                     {
 127   5                     if((sensor_detect == 0)&&(stolen_alarm_flag == 0))    //¼ì²â´«¸ÐÆ÷Ê±ºòÓÐ±¨¾¯ÐÅºÅ½øÀ´£¬²¢ÇÒÃ»ÓÐÅÐ¶¨Îª±»µ
             -Á¡£¼´ÔÚ±»µÁ±¨¾¯µÄÊ±ºò£¬²»½øÐÐ´Ë¼ì²â
 128   5                        {
 129   6                        sensor_1ststage_count++;
 130   6                        if(sensor_1ststage_count>=2)            //Ã¿1ms¼ì²âÒ»´Î¸ßµçÆ½£¬Èç¹û´óÓÚÁË2msµÄ¸ß¶¨Æ½£¬ËµÃ÷ÓÐÈËÅöÁËÒ»ÏÂ
 131   6                           {
 132   7                           sensor_1ststage_count=0;
 133   7                           sensor_trigger_count = 1;
 134   7                           host_touch_speech_EN = 1;
 135   7                           }
 136   6                        }
 137   5                     else
 138   5                        {
 139   6                        sensor_1ststage_count = 0;
 140   6                        }
 141   5                     }
 142   4                  break;
 143   4                  
 144   4                  case 1:
 145   4                     {
 146   5                     if(sensor_detect == 0)
 147   5                        {
 148   6                        sensor_2ndstage_count++;
 149   6                        if(sensor_2ndstage_count >= 2)
 150   6                           {
 151   7                           sensor_2ndstage_count = 0;
 152   7                           sensor_trigger_count = 2;
 153   7                           host_2ndtouch_speech_EN = 1;
 154   7                           host_2ndtouch_speech_count = 0;
 155   7                           }
 156   6                        }
 157   5                     else
 158   5                        {
 159   6                        sensor_2ndstage_count = 0;
 160   6                        }
 161   5                     
 162   5                     sensor_2ndstage_time++;
 163   5                     if(sensor_2ndstage_time >= 4000)
 164   5                        {
 165   6                        sensor_trigger_count = 0;
 166   6                        sensor_2ndstage_count = 0;
 167   6                        sensor_1ststage_count = 0;
 168   6                        sensor_2ndstage_time = 0;
 169   6                        }
 170   5                     }
 171   4                  break;
 172   4                  
 173   4                  case 2:
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 4   

 174   4                     {
 175   5                     if(sensor_detect == 0)
 176   5                        {
 177   6                        sensor_3rdstage_count++;
 178   6                        if(sensor_3rdstage_count >= 2)
 179   6                           {
 180   7                           sensor_3rdstage_count = 0;
 181   7                           host_stolen_alarm1_EN = 1;
 182   7                           host_stolen_alarm2_EN = 1;                
 183   7                           }
 184   6                        }
 185   5                     else
 186   5                        {
 187   6                        sensor_3rdstage_count = 0;
 188   6                        }
 189   5                     
 190   5                     sensor_3rdstage_time++;
 191   5                     if(sensor_3rdstage_time >= 4000)
 192   5                        {
 193   6                        sensor_trigger_count = 0;
 194   6                        sensor_1ststage_count = 0;
 195   6                        sensor_2ndstage_count = 0;
 196   6                        sensor_2ndstage_time = 0;
 197   6                        sensor_3rdstage_time = 0;
 198   6                        sensor_3rdstage_interval = 800;
 199   6                        sensor_3rdstage_count = 0;
 200   6                        sensor_3rdstage_effcount = 0;             
 201   6                        }
 202   5                     }
 203   4                  break;
 204   4                  }
 205   3               }
 206   2            
 207   2            
 208   2            if((host_touch_speech_EN == 1)&&(host_touch_speech_count < 1))
 209   2               {
 210   3               host_touch_speech();
 211   3                  
 212   3               if(++host_touch_speech_count >= 1)
 213   3                  {
 214   4                  host_touch_speech_count = 0;
 215   4                  host_touch_speech_EN = 0;
 216   4                  }
 217   3               }
 218   2            
 219   2            if((host_2ndtouch_speech_EN == 1)&&(host_2ndtouch_speech_count < 1))
 220   2               {
 221   3               host_2ndtouch_speech();
 222   3                  
 223   3               if(++host_2ndtouch_speech_count >= 1)
 224   3                  {
 225   4                  host_2ndtouch_speech_count = 0;
 226   4                  host_2ndtouch_speech_EN = 0;
 227   4                  }
 228   3               }
 229   2            }
 230   1         
 231   1      
 232   1      // ¼ì²âµ¹µØºÍÌ§Æð¼ì²âµÄ´úÂë
 233   1         if(position_sensor_EN==1)        //¿ªÆôÁËÌ§Æðµ¹µØ¼ì²â
 234   1         {
 235   2            if(raised_sensor_detect == 0) //ËµÃ÷ÓÐÌ§ÆðÐÅºÅ²¢ÇÒÊÇµÚÒ»´Î£¬¿ªÊ¼¼ÆÊ±
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 5   

 236   2            {
 237   3               raise_wire_time++;
 238   3               if(raise_wire_time==10) //ËµÃ÷ÒÑ¾­´óÓÚ0.5S
 239   3               {
 240   4                  raised_flag=1;          //ÖÃÌ§Æð±êÖ¾
 241   4                  fell_flag=0;
 242   4                  if(raised_fell_once_flag == 0)
 243   4                     {
 244   5                     raised_fell_flag = 1;               
 245   5                     }
 246   4               }     
 247   3            }
 248   2            else
 249   2            {
 250   3               raised_flag=0;
 251   3               raised_alarm_count=0;
 252   3               raise_wire_time=0;
 253   3               raised_fell_flag = 0;
 254   3            }
 255   2      
 256   2            if(fell_sensor_detect==0)
 257   2            {
 258   3               fell_wire_time++;
 259   3               if(fell_wire_time==10)     //ËµÃ÷ÒÑ¾­´óÓÚ0.5s
 260   3               {
 261   4                  fell_flag=1;            //ÖÃÌ§Æð±êÖ¾
 262   4                  raised_flag=0;
 263   4                  if(raised_fell_once_flag == 0)
 264   4                     {
 265   5                     raised_fell_flag = 1;               
 266   5                     }
 267   4               }     
 268   3            }
 269   2            else
 270   2            {
 271   3               fell_flag=0;
 272   3               fell_alarm_count=0;
 273   3               fell_wire_time=0;
 274   3               raised_fell_flag = 0;
 275   3            }
 276   2         }
 277   1         
 278   1         if(raised_fell_flag == 1)
 279   1            {
 280   2            raised_fell_number++;
 281   2            if(raised_fell_number >= 10000)
 282   2               {
 283   3               raised_fell_flag = 0;
 284   3               raised_fell_number = 0;
 285   3               raised_fell_once_flag = 1;
 286   3               
 287   3               sensor_trigger_count = 0;
 288   3               sensor_1ststage_count = 0;
 289   3               sensor_2ndstage_count = 0;
 290   3               sensor_2ndstage_time = 0;
 291   3               sensor_3rdstage_time = 0;
 292   3               sensor_3rdstage_interval = 800;
 293   3               sensor_3rdstage_count = 0;
 294   3               sensor_3rdstage_effcount = 0;             
 295   3               }
 296   2            }
 297   1      }
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 6   

 298          
 299          
 300          /*------------------------------------------------------------------
 301             timerT1()
 302             ¶¨Ê±Æ÷1Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
 303          --------------------------------------------------------------------*/
 304          
 305          void timerT1() interrupt interrupt_timer_1_overflow
 306          {
 307   1      
 308   1         TH1 = timer1_8H;              //ÖØ×°ÔØ
 309   1         TL1 = timer1_8L;
 310   1         
 311   1         if(P11==0)//Õý³£Çé¿öÎª¸ßµçÆ½,ÓÐµÍµçÆ½ËµÃ÷ÓÐÐÅºÅ
 312   1         {
 313   2            receive_LV_count++;
 314   2            receive_wire_flag=0;
 315   2            if(receive_LV_count==80)//µÍµçÆ½³ÖÐøµÄ×î´óÊ±¼ä  
 316   2            {
 317   3               receive_LV_count=0;
 318   3            }
 319   2         }
 320   1         else//Îª¸ßµçÆ½ÁË
 321   1         {
 322   2            if(receive_wire_flag==0)//ËµÃ÷ÓÐÒ»¸öµÍµçÆ½
 323   2            {
 324   3               receive_wire_flag=1;
 325   3      
 326   3               if((receive_LV_count>35)&&(receive_LV_count<=50))  //µÍµçÆ½³ÖÐøµÄÊ±¼äÐ¡ÓÚ10ms£¬ÔòÎª0
 327   3               {
 328   4                  one_receive_byte<<=1;
 329   4                  one_receive_byte &= 0xfe;
 330   4                  one_receive_byte_count++;
 331   4                  receive_HV_count=0;
 332   4               }
 333   3               else if((receive_LV_count>50))//µÍµçÆ½³ÖÐøµÄÊ±¼ä´óÓÚ4.5ms£¬ÔòÎª1
 334   3               {
 335   4                  one_receive_byte<<=1;
 336   4                  one_receive_byte |= 0x01;
 337   4                  one_receive_byte_count++;
 338   4                  receive_HV_count=0;
 339   4               }
 340   3               else
 341   3               {
 342   4                  receive_HV_count++;  
 343   4               }
 344   3      
 345   3               receive_LV_count=0;
 346   3            }
 347   2      
 348   2            else
 349   2            {
 350   3               receive_HV_count++;
 351   3               if(receive_HV_count>=60)
 352   3               {
 353   4                  one_receive_byte_count=0;
 354   4                  receive_wire_flag=1;
 355   4                  data_count=0;
 356   4               }     
 357   3            }
 358   2         }
 359   1      
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 7   

 360   1         if(one_receive_byte_count==8)//ËµÃ÷Ò»¸ö×Ö½ÚµÄÊý¾ÝÒÑ¾­½ÓÊÜÍêÈ«
 361   1         {
 362   2            one_receive_byte_count=0;
 363   2            received_data_buffer[data_count]=one_receive_byte;
 364   2            if(data_count==0&&received_data_buffer[0] == CmdHead)
 365   2            {
 366   3               data_count=1;
 367   3            }
 368   2            else if(data_count==1&&received_data_buffer[1]==MyAddress)
 369   2            {
 370   3               data_count=2;
 371   3            }
 372   2            else if(data_count==2)
 373   2            {
 374   3               receive_data_finished_flag=1;
 375   3               data_count=0;
 376   3            }
 377   2            else 
 378   2            {
 379   3               data_count=0;
 380   3            }
 381   2         }
 382   1      
 383   1         if(receive_data_finished_flag==1)
 384   1         {
 385   2            receive_data_finished_flag=0;
 386   2            switch(received_data_buffer[2])     //¶ÔÊý¾ÝÖ¡ÀïµÄÃüÁî½øÐÐ´¦Àí
 387   2            {
 388   3               case ComMode_1:      //¸½»ú·¢ËÍ¹ýÀ´µÄÖ»ÓÃÄ£Ê½1£¬ËµÃ÷ÏÖÔÚÊÇÕý³£µÄ£¬Êý¾Ý²¿·ÖÎªÊý×éµÄµÚÒ»ºÍµÚ¶þ¸ö×Ö½Ú£¬ÎªÃÜÂ
             -ë±íÄÚµÄÕâ¸ö±àÂëµÄ¿ªÊ¼×Ö½ÚµÄÄÇ¸öµØÖ·£¬È»ºóÌî³äÊý¾ÝÖ¡£¬°ÑÃÜÂë±íµÄÊý¾Ý·¢ËÍ³öÈ¥
 389   3               {
 390   4                  ComMode_1_Data();    //Ïò¸½»ú·¢ËÍ±àÂë3
 391   4      
 392   4                  slave_nearby_speech_EN=1;     //±àÂë1ºó±¨Ò»¾äÓïÒô
 393   4      
 394   4                  sensor_EN=0;   //ÈýÖá´«¸ÐÆ÷
 395   4                  position_sensor_EN=0;      //¹Øµ¹µØ¡¢Ì§Æð¼ì²â
 396   4                  fell_flag=0;  
 397   4                  raised_flag=0;
 398   4                  magnet_CW_EN=1;         //´ò¿ªµç´ÅÌú
 399   4                  
 400   4                  sensor_trigger_count = 0;
 401   4                  sensor_1ststage_count = 0;
 402   4                  sensor_2ndstage_count = 0;
 403   4                  sensor_2ndstage_time = 0;
 404   4                  sensor_3rdstage_time = 0;
 405   4                  sensor_3rdstage_interval = 0;
 406   4                  sensor_3rdstage_count = 0;
 407   4                  sensor_3rdstage_effcount = 0;
 408   4                  stolen_alarm_flag = 0;
 409   4                  host_stolen_alarm1_EN = 0;
 410   4                  host_stolen_alarm1_count = 0;
 411   4                  host_stolen_alarm2_EN = 0;
 412   4                  host_stolen_alarm2_count = 0;
 413   4                  
 414   4                  raised_fell_flag = 0;
 415   4                  
 416   4                  leave_count=0; 
 417   4                  if(slave_away==1)
 418   4                  {
 419   5                     slave_away=0;
 420   5                  }
C51 COMPILER V9.51   TIMER                                                                 12/05/2013 14:04:14 PAGE 8   

 421   4               }
 422   3               break;
 423   3            }
 424   2         }
 425   1      }
 426          
 427          /*--------------------------------------------------
 428             InitTimer()
 429             
 430             ³õÊ¼»¯¶¨Ê±Æ÷T0ºÍT1
 431          ---------------------------------------------------*/
 432          
 433          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
 434             {
 435   1         tLong Inc_T0, Inc_T1;
 436   1         tWord timer0_16, timer1_16;
 437   1         
 438   1         //¼ÆËãTimer0µÄ¼Ä´æÆ÷Öµ
 439   1         Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
 440   1         timer0_16 = (tWord) (65536UL - Inc_T0);
 441   1         timer0_8H = (tByte) (timer0_16 / 256);
 442   1         timer0_8L = (tByte) (timer0_16 % 256);
 443   1         
 444   1         //¼ÆËãTimer1µÄ¼Ä´æÆ÷Öµ
 445   1         Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
 446   1         timer1_16 = (tWord) (65536UL - Inc_T1);
 447   1         timer1_8H = (tByte) (timer1_16 / 256);
 448   1         timer1_8L = (tByte) (timer1_16 % 256);
 449   1         
 450   1         TMOD = 0x11;
 451   1         
 452   1         TH0 = timer0_8H;
 453   1         TL0 = timer0_8L;
 454   1         TH1 = timer1_8H;
 455   1         TL1 = timer1_8L;
 456   1      
 457   1         ET0 = 1;
 458   1         TR0 = 1;
 459   1         ET1 = 1;
 460   1         TR1 = 1;
 461   1         PT1 = 1;       
 462   1         EA = 1;
 463   1         }
 464             
 465          /*---------------------------------------------------
 466             end of file
 467          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    943    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     19    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
