C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NEWSLAVE
OBJECT MODULE PLACED IN .\out\newSlave.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE newSlave.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\listing\newSlave.lst) OBJECT(.\out\newSlave.obj)

line level    source

   1          #include"N79E81x.h"
   2          #include<intrins.h>
   3          #include"AD.h"
   4          #include"UART.h"
   5          #include"T0.h"
   6          #include"voice.h"
   7          #include"pwm.h"
   8          #include"T1.h"
   9          
  10          //定义通信命令
  11          #define CmdStart 0x00 //开机命令
  12          #define CmdStop 0x01  //关机命令
  13          #define ComMode_1 0xc1 //通信模式1 
  14          #define ComMode_2 0xc2 //通信模式2
  15          #define ComMode_3 0xc3 //通信模式3
  16          #define ComMode_4 0xc4 //抬起指令
  17          #define ComMode_5 0xc5//倒地指令
  18          #define ComMode_6 0xc6//充电已满指令
  19          #define Succeed 0xce  //通信成功
  20          #define Wrong 0xff    //通信失败
  21          #define CmdHead 0xc8
  22          #define CmdHead1 0x33 //数据帧的首部1, 00110011,11
  23          #define CmdHead2 0xcc //数据帧的首部2,11001100,00
  24          #define CmdHead3 0x3c //数据帧的首部3,11000011,01
  25          #define CmdHead4 0xcc //数据帧的首部4,11001100,00
  26          #define MyAddress 0xe0
  27          #define MyAddress1 0x33 //本机地址1, 00110011,11
  28          #define MyAddress2 0x3c //本机地址2, 11000011,01
  29          #define MyAddress3 0xcc //本机地址3,11001100,00
  30          #define MyAddress4 0xcc //本机地址4,11001100,00
  31          
  32          sbit ModeControl_1=P2^6;        //发射机模式控制,0为大功率，1为小功率
  33          sbit Moto=P2^4;                         //振动器控制，0振动，1不振动
  34          sbit receive_en=P1^3;           //接收机使能，1打开接收机，0关闭接收机，要加上拉电阻
  35          sbit tran_en=P2^7;                      //发射机使能，1打开发射机，0关闭发射机
  36          sbit PAshutdown=P1^4;           //功放开关控制，1为打开功放，0为关闭功放
  37          
  38          
  39          bit ModeFlag=0;                         //模式选择位，0则用模式1,1则用模式2
  40          bit receiveFlag=0;                      //接收到数据标志
  41          bit commuFlag=0;                        //开启通信标志
  42          
  43          bit alarmFlag2=0;                       //是否继续报警标志
  44          bit alarmFlag3=0;                       //是否继续报警标志
  45          bit alarmFlag4=0;                       //抬起报警
  46          bit alarmFlag5=0;                       //倒地报警
  47          unsigned int alarmCount2=0;     //报警2循环次数
  48          unsigned int alarmCount3=0;     //报警3循环次数
  49          unsigned int alarmCount4=0;     //抬起报警循环次数
  50          unsigned int alarmCount5=0;     //倒地报警循环次数
  51          
  52          unsigned char voiceFlag=0;      //声音循环开关 
  53          
  54          unsigned char dataFirst=0;      //用于存储上次编码类型
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 2   

  55          
  56          unsigned char count=0;          //串口接收部分的计数器
  57           
  58          unsigned int time0Count_3=0;//作为串口每秒主辅机的信息交互时钟
  59          
  60          unsigned int lastAddr=0;        //上一次接收到的编码的地址
  61          unsigned int TestFlag=0;        //1、2、3分别为每1S后的计数，在串口的成功指令里会执行将去归零的操作
  62                                                  //如果连续3次都没有归零，则说明不在场了
  63          
  64          //作为接收和发送的缓存区
  65          unsigned char TxRxBuf[28]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
             -,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  66          //一个头字节，一个地址字节，一个命令字节，两个编码地址字节，两个编码
  67          unsigned char myTxRxData[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};//处理完后的通信数据的缓冲区
  68          unsigned char myTxRxData2[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};       //接收数据的缓存
  69          
  70          unsigned int Check=0;           //作为AD检测值
  71          bit checkFlag=0;                        //电量检测标志
  72           
  73          unsigned char DataBetween=0;    //作为接收数据的中间变量
  74          unsigned char RecData=0;                //接收到的数据
  75          unsigned char DataTime=0;               //作为接收的数据的移位次数计数
  76          bit ComFlag=1;                                  //做上升沿的一个标志
  77          unsigned char T1highcount=0;    //定时器T1在没有信号到来的时候，对高电平计数，一旦超过某个值，则将Datatime清0
  78          
  79          bit ADCcheck=0;                 //置1时，执行一次电量转换，执行完后，将其置0
  80          bit sendcomm1=0;                //置1时，执行一次发送编码1，执行完后，将其置0
  81          bit sendspeech1=0;              //置1时，执行一次语音提示，表示充电已满
  82          unsigned char speech1_count=0;  
  83          unsigned char powerflag=1;              //电池电位的标记，1表示现在电池是满的，0表示还没满。
  84          
  85          
  86          
  87          void ComMode_1_Data(void);              //发送编码1
  88          
  89          void Delay3(unsigned int t)             //t=1时，延迟100us左右
  90          {
  91   1              unsigned int i,j;
  92   1              for(i=0;i<t;i++)                
  93   1              for(j=0;j<23;j++);
  94   1      }
  95          
  96          void initsignal()                               //init signal，发送编码信号前的起始信号，用于将接收机的自动增益打开
  97          {
  98   1              unsigned char k,k1;
  99   1              unsigned char mystartbuffer=0xaa;
 100   1              for(k1=0;k1<1;k1++)
 101   1              {
 102   2                      for(k=0;k<8;k++)
 103   2                      {
 104   3                              if((mystartbuffer&0x80)==0x80)//为1
 105   3                              {
 106   4                                      P10=0;
 107   4                                      Delay3(80);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 108   4                              }
 109   3                              else//为0的情况
 110   3                              {
 111   4                                      P10=0;
 112   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 113   4                              }
 114   3                              P10=1;//常态为高电平
 115   3                              mystartbuffer<<=1;
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 3   

 116   3                              Delay3(150);//延时要大于2ms
 117   3                      }
 118   2                      mystartbuffer=0xaa;
 119   2                      Delay3(80);
 120   2              }
 121   1              P10=1;
 122   1      }
 123          
 124          void main(void)
 125          {
 126   1              noVoice();
 127   1              InitT0();
 128   1              InitT1();
 129   1              Moto=1;                 //关闭马达
 130   1      
 131   1              ET0=1;
 132   1              ET1=1;
 133   1              PT1=1;                  //定时器1的中断优先级最高
 134   1              EA=1;
 135   1      
 136   1              myPwm();                //开发射机
 137   1              P10=1;
 138   1              PAshutdown=0;                   //开机时，将功放关闭
 139   1              
 140   1              Check=GetADCResult(6);  //上电时，电池电量检测一次
 141   1              
 142   1              commuFlag=1;                    //开启通信
 143   1              alarmCount3=0;                  //清报警计数器
 144   1              alarmFlag3=0;                   //清报警标志
 145   1      
 146   1      //      receive_en=1;
 147   1      
 148   1              while(1)
 149   1              {
 150   2                      if(alarmFlag3==1)               //编码3开始相应的报警
 151   2                      {
 152   3                              if(alarmCount3<2)
 153   3                              {
 154   4                                      PAshutdown=1;
 155   4                                      SC_Speech(5);
 156   4                                      Delay(150);
 157   4                                      SC_Speech(6);
 158   4                                      Delay(80);
 159   4                                      SC_Speech(7);
 160   4                                      Delay(120);
 161   4                                      PAshutdown=0;
 162   4                                      
 163   4                                      Moto=0;                         
 164   4                                      Delay(10);
 165   4                                      Moto=1;
 166   4                                      alarmCount3++;
 167   4                              }
 168   3                      }
 169   2      
 170   2                      if(alarmFlag4==1)               //抬起开始相应的报警
 171   2                      {
 172   3      
 173   3                                      PAshutdown=1;
 174   3                                      SC_Speech(4);
 175   3                                      Delay(180);
 176   3                                      
 177   3                                      Moto=0;
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 4   

 178   3                                      Delay(10);
 179   3                                      Moto=1;
 180   3                                      alarmFlag4=0;
 181   3                      }
 182   2      
 183   2                      if(alarmFlag5==1)//倒地开始相应的报警
 184   2                      {
 185   3                                      PAshutdown=1;
 186   3                                      SC_Speech(8);
 187   3                                      Delay(180);
 188   3              
 189   3                                      Moto=0;//开震动
 190   3                                      Delay(10);
 191   3                                      Moto=1;
 192   3      
 193   3                                      alarmFlag5=0;
 194   3                      }
 195   2      
 196   2                      if(ADCcheck==1)                         //每个3s检测一次电量，如果电池满的就检测是否低了，如果是不满的就检测是否充满。
 197   2                      {
 198   3                              Check=GetADCResult(6);  //电池电量检测
 199   3                              ADCcheck=0;
 200   3                              
 201   3                              if((powerflag==1)&&(Check<=0x35a))
 202   3                              {
 203   4                                      powerflag=0;
 204   4                                      PAshutdown=1;
 205   4                                      SC_Speech(9);   //电压不充足提示
 206   4                                      Delay(120);
 207   4                                      PAshutdown=0;
 208   4                              }
 209   3                              else if((powerflag==0)&&(Check>=0x377))
 210   3                              {
 211   4                                      powerflag=1;
 212   4                                      PAshutdown=1;
 213   4                                      SC_Speech(2);   //电压充足提示
 214   4                                      Delay(120);
 215   4                                      PAshutdown=0;
 216   4                              }       
 217   3                      }
 218   2      
 219   2                      if(sendcomm1==1)
 220   2                      {
 221   3                              receive_en=0;           //打开接收机
 222   3                              ComMode_1_Data();       //发送模式1信号
 223   3                              receive_en=1;           //打开接收机
 224   3                              sendcomm1=0;
 225   3                      }
 226   2      
 227   2                      if(sendspeech1==1)
 228   2                      {
 229   3                              PAshutdown=1;
 230   3                              SC_Speech(2);  
 231   3                              Delay(80);
 232   3                              SC_Speech(3);  
 233   3                              Delay(80);
 234   3                              PAshutdown=0;
 235   3                              sendspeech1=0;
 236   3                      }
 237   2              }
 238   1      }
 239          
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 5   

 240          void timeT1() interrupt 3                               //定时器1中断接收数据
 241          {
 242   1              TH1=timer1H;                                            //重装载
 243   1              TL1=timer1L;
 244   1      
 245   1              if(P11==0)                                                      //正常情况为高电平,有低电平说明有信号
 246   1              {
 247   2                      DataBetween++;
 248   2                      ComFlag=0;
 249   2                      if(DataBetween==150)                    //低电平持续的最大时间  
 250   2                      {
 251   3                              DataBetween=0;
 252   3                      }
 253   2              }
 254   1              else//为高电平了
 255   1              {
 256   2                      if(ComFlag==0)//说明有一个低电平
 257   2                      {
 258   3                              ComFlag=1;
 259   3      //                      RecData<<=1;
 260   3      
 261   3                              if((DataBetween>60)&&(DataBetween<=100))//低电平持续的时间小于3ms，则为0
 262   3                              {
 263   4                                      RecData<<=1;
 264   4                                      RecData &= 0xfe;
 265   4                                      DataTime++;
 266   4                                      T1highcount=0;
 267   4                              }
 268   3                              if(DataBetween>100)//低电平持续的时间大于4.5ms，则为1
 269   3                              {
 270   4                                      RecData<<=1;
 271   4                                      RecData |= 0x01;
 272   4                                      DataTime++;
 273   4                                      T1highcount=0;
 274   4                              }
 275   3                              else
 276   3                              {
 277   4                                      T1highcount++;  
 278   4                              }
 279   3      
 280   3                              DataBetween=0;
 281   3                      }
 282   2                      else
 283   2                      {
 284   3                              T1highcount++;
 285   3                              if(T1highcount>=120)
 286   3                              {
 287   4                                      DataTime=0;
 288   4                                      ComFlag=1;
 289   4                                      count=0;
 290   4                              }               
 291   3                      }
 292   2              }
 293   1      
 294   1              if(DataTime==8)//说明一个字节的数据已经接受完全
 295   1              {
 296   2                      DataTime=0;
 297   2                      myTxRxData2[count]=RecData;
 298   2                      if(count==0&&myTxRxData2[0]==CmdHead)
 299   2                      {
 300   3                              count=1;
 301   3                      }
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 6   

 302   2                      else if(count==1&&myTxRxData2[1]==MyAddress)
 303   2                      {
 304   3                              count=2;
 305   3                      }
 306   2                      else if(count==2)
 307   2                      {
 308   3                              receiveFlag=1;
 309   3                              count=0;
 310   3                      }
 311   2                      else 
 312   2                      {
 313   3                              count=0;
 314   3                      }
 315   2      
 316   2      /*
 317   2                      else if(count>=2&&count<=5)
 318   2                      {
 319   2                              count++;
 320   2                      }
 321   2                      else if(count==6)
 322   2                      {
 323   2                              receiveFlag=1;
 324   2                              count=0;
 325   2                      }
 326   2                      else 
 327   2                      {
 328   2                              count=0;
 329   2                      }
 330   2      */
 331   2              }
 332   1      
 333   1              if(receiveFlag==1)      //说明接收到了数据，开始处理
 334   1              {
 335   2                      receiveFlag=0;  //清接收标志
 336   2                      receive_en=0;                   //关闭接收机
 337   2                      switch(myTxRxData2[2])//解析指令
 338   2                      {
 339   3                              case ComMode_1://接收到的是主机发送过来的编码1的信号，说明主机在3M内，是正常的
 340   3                              {       
 341   4                                      TestFlag=0;//正常情况，清超时标志
 342   4      
 343   4                                      alarmCount3=0;//清报警计数器
 344   4                                      alarmFlag3=0;//清报警标志
 345   4      
 346   4                                      alarmCount4=0;//清报警计数器
 347   4                                      alarmFlag4=0;//清报警标志
 348   4      
 349   4                                      alarmCount5=0;//清报警计数器
 350   4                                      alarmFlag5=0;//清报警标志
 351   4      
 352   4                                      Moto=0;//开震动
 353   4                                      Delay(10);
 354   4                                      Moto=1;
 355   4                              }
 356   3                              break;
 357   3                      
 358   3                              case ComMode_3:
 359   3                              {
 360   4                                      TestFlag=0;//清超时标志                         
 361   4                                      alarmFlag3=1;
 362   4      
 363   4                                      alarmCount4=0;//清报警计数器
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 7   

 364   4                                      alarmFlag4=0;//清报警标志
 365   4                                      alarmCount5=0;//清报警计数器
 366   4                                      alarmFlag5=0;//清报警标志
 367   4      
 368   4                                      Moto=0;         //开震动
 369   4                                      Delay(10);
 370   4                                      Moto=1;
 371   4                              }
 372   3                              break;
 373   3                      
 374   3                              case ComMode_4://留作抬起信号使用
 375   3                              {
 376   4                                      TestFlag=0;//清超时标志 
 377   4                                      alarmFlag4=1;//抬起报警
 378   4      
 379   4                                      alarmCount3=0;//清报警计数器
 380   4                                      alarmFlag3=0;//清报警标志
 381   4                                      alarmCount5=0;//清报警计数器
 382   4                                      alarmFlag5=0;//清报警标志
 383   4      
 384   4                                      Moto=0;         //开震动
 385   4                                      Delay(10);
 386   4                                      Moto=1;
 387   4                              }
 388   3                              break;
 389   3      
 390   3                              case ComMode_5://留作倒地信号使用
 391   3                              {
 392   4                                      TestFlag=0;//清超时标志
 393   4                                      alarmFlag5=1;   //倒地报警
 394   4      
 395   4                                      alarmCount3=0;//清报警计数器
 396   4                                      alarmFlag3=0;//清报警标志
 397   4                                      alarmCount4=0;//清报警计数器
 398   4                                      alarmFlag4=0;//清报警标志
 399   4      
 400   4                                      Moto=0;         //开震动
 401   4                                      Delay(10);
 402   4                                      Moto=1;
 403   4                              }
 404   3                              break;
 405   3      
 406   3                              case ComMode_6://留作倒地信号使用
 407   3                              {
 408   4                                      sendspeech1=1;
 409   4                              }
 410   3                              break;
 411   3                      }
 412   2              }
 413   1      }
 414          
 415          void time0() interrupt 1        //作为整个系统自己的时钟
 416          {
 417   1              TH0=timer0H;//重装载
 418   1              TL0=timer0L;
 419   1      
 420   1              time0Count_3++;
 421   1      
 422   1              if(time0Count_3>=60)            //串口每1S发送一次的数据的时间标志
 423   1              {
 424   2                      ADCcheck=1;
 425   2                      if(commuFlag==1)                //说明开启了通信
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 8   

 426   2                      {
 427   3                              TestFlag++;
 428   3                              sendcomm1=1;
 429   3                              if(TestFlag>=4)         //说明已经出了300M了。收不到任何信号了，要做报警
 430   3                              {
 431   4                                      TestFlag=5;
 432   4                              }
 433   3                      }
 434   2                      time0Count_3=0;
 435   2              }
 436   1      
 437   1              if(alarmCount3>=2)
 438   1              {
 439   2                      alarmCount3++;
 440   2                      if(alarmCount3==2400)
 441   2                      {
 442   3                              alarmCount3=0;
 443   3                              alarmFlag3=0;
 444   3                      }
 445   2              }
 446   1      }
 447          
 448          void ComMode_1_Data()                   //发送编码1
 449          {
 450   1              unsigned char i,n;
 451   1      
 452   1              ModeControl_1=0;//30M发射功率                           
 453   1              tran_en=1;      //打开无线发射机
 454   1              myTxRxData[0]=CmdHead;
 455   1              myTxRxData[1]=MyAddress;
 456   1              myTxRxData[2]=ComMode_1;
 457   1      /*      myTxRxData[3]=0x00;
 458   1              myTxRxData[4]=0x00;
 459   1              myTxRxData[5]=0x00;
 460   1              myTxRxData[6]=0x00;
 461   1      */
 462   1              initsignal();
 463   1      
 464   1              for(i=0;i<3;i++)
 465   1              {
 466   2                      for(n=0;n<8;n++)
 467   2                      {
 468   3                              if((myTxRxData[i]&0x80)==0x80)//为1
 469   3                              {
 470   4                                      P10=0;
 471   4                                      Delay3(120);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 472   4                              }
 473   3                              else//为0的情况
 474   3                              {
 475   4                                      P10=0;
 476   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 477   4                              }
 478   3                              P10=1;//常态为高电平
 479   3                              myTxRxData[i]<<=1;
 480   3                              Delay3(50);//延时要大于2ms
 481   3                      }
 482   2              }
 483   1              tran_en=0;
 484   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.01   NEWSLAVE                                                              08/24/2013 09:55:08 PAGE 9   

   CODE SIZE        =    922    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     67       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
