C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NEWSLAVE
OBJECT MODULE PLACED IN .\out\newSlave.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE newSlave.c BROWSE DEBUG OBJECTEXTEND PRINT(.\listing\ne
                    -wSlave.lst) OBJECT(.\out\newSlave.obj)

line level    source

   1          
   2          
   3          #include"N79E81x.h"
   4          #include<intrins.h>
   5          #include"AD.h"
   6          #include"UART.h"
   7          #include"T0.h"
   8          #include"voice.h"
   9          #include"pwm.h"
  10          #include"T1.h"
  11          
  12          //定义通信命令
  13          
  14          #define CmdStart 0x00 //开机命令
  15          #define CmdStop 0x01  //关机命令
  16          
  17          #define ComMode_1 0xc1 //通信模式1 
  18          #define ComMode_2 0xc2 //通信模式2
  19          #define ComMode_3 0xc3 //通信模式3
  20          #define ComMode_4 0xc4 //抬起指令
  21          #define ComMode_5 0xc5//倒地指令
  22          
  23          #define Succeed 0xce  //通信成功
  24          #define Wrong 0xff    //通信失败
  25          
  26          #define CmdHead 0xc8
  27          #define CmdHead1 0x33 //数据帧的首部1, 00110011,11
  28          #define CmdHead2 0xcc //数据帧的首部2,11001100,00
  29          #define CmdHead3 0x3c //数据帧的首部3,11000011,01
  30          #define CmdHead4 0xcc //数据帧的首部4,11001100,00
  31          
  32          #define MyAddress 0xe0
  33          #define MyAddress1 0x33 //本机地址1, 00110011,11
  34          #define MyAddress2 0x3c //本机地址2, 11000011,01
  35          #define MyAddress3 0xcc //本机地址3,11001100,00
  36          #define MyAddress4 0xcc //本机地址4,11001100,00
  37          
  38          //三路循环
  39          sbit onePin=P1^6;
  40          sbit twoPin=P1^7;
  41          sbit threePin=P0^0;
  42          
  43          //附机的发射部分的控制端口
  44          //sbit PWMout=P3^5;//发射机的方波输出口，现在使用PWM外设了
  45          sbit ModeControl_1=P2^6;//发射机模式控制,0亮为1.5M模式，1灭为3M模式
  46          
  47          //接收机控制
  48          //sbit SwitchControl=P1^3;      //1关闭接收机，0开启接收机
  49          
  50          //开关按键
  51          sbit Turn=P0^3;//开关
  52          
  53          //模式选择按键
  54          sbit ModeChange=P0^4;
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 2   

  55          
  56          //马达控制端
  57          sbit Moto=P2^4;
  58          
  59          //电池控制      AD的1号通道为电池的电量检测端
  60          sbit BatteryControl=P1^2;
  61          
  62          //接收机控制
  63          //sbit SwitchControl=P1^3;      //1有效，0关闭
  64          //发射机pin18
  65          //sbit tran_out=P1^0;
  66          
  67          //无线发射机控制
  68          sbit tran_en=P2^7;//发射机开关，1亮为开了，0灭为关了
  69          
  70          //开机状态标记位
  71          bit TurnFlag=0;//0位关机状态，1为开机状态
  72          
  73          //模式选择位，0则用模式1,1则用模式2
  74          bit ModeFlag=0;
  75          
  76          bit receiveFlag=0;//接收到数据标志
  77          bit commuFlag=0;//开启通信标志
  78          
  79          bit alarmFlag2=0;//是否继续报警标志
  80          bit alarmFlag3=0;//是否继续报警标志
  81          bit alarmFlag4=0;       //抬起报警
  82          bit alarmFlag5=0;       //倒地报警
  83          unsigned int alarmCount2=0;//报警2循环次数
  84          unsigned int alarmCount3=0;//报警3循环次数
  85          unsigned int alarmCount4=0;//抬起报警循环次数
  86          unsigned int alarmCount5=0;//倒地报警循环次数
  87          
  88          bit threeFlag=0;//三路循环开关标志
  89          
  90          bit power1Flag=0;
  91          bit power2Flag=0;
  92          bit power3Flag=0;
  93          bit power4Flag=0;
  94          
  95          unsigned char voiceFlag=0;//声音循环开关 
  96          
  97          unsigned char dataFirst=0;//用于存储上次编码类型
  98          
  99          unsigned char count=0;//串口接收部分的计数器
 100           
 101          unsigned int time0Count_3=0;//作为串口每秒主辅机的信息交互时钟
 102          
 103          unsigned int lastAddr=0;//上一次接收到的编码的地址
 104          unsigned int TestFlag=0;//1、2、3分别为每1S后的计数，在串口的成功指令里会执行将去归零的操作
 105                                          //如果连续3次都没有归零，则说明不在场了
 106          
 107          //作为接收和发送的缓存区
 108          unsigned char TxRxBuf[28]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
             -,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
 109          //一个头字节，一个地址字节，一个命令字节，两个编码地址字节，两个编码
 110          unsigned char myTxRxData[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};//处理完后的通信数据的缓冲区
 111          
 112          unsigned int time0Count_Clock=0;//电量检测时钟
 113          unsigned int Check=0;//作为AD检测值
 114          bit checkFlag=0;//电量检测标志
 115           
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 3   

 116          unsigned char DataBetween=0;//作为接收数据的中间变量
 117          unsigned char RecData=0;//接收到的数据
 118          unsigned char DataTime=0;//作为接收的数据的移位次数计数
 119          bit ComFlag=1;//做上升沿的一个标志
 120          unsigned char T1highcount=0;       //定时器T1在没有信号到来的时候，对高电平计数，一旦超过某个值，则将Datatime
             -清0
 121          
 122          //功放开关控制，1为打开功放，0为关闭功放
 123          sbit PAshutdown=P1^4;
 124          
 125          //定义一个计数，来表示信号接收后，多长时间使接收机打开，即控制SwitchControl的高电平时间。
 126          //unsigned int SwitchControlcount=0;
 127            
 128          //函数声明
 129          //void codeData(unsigned char *doData,unsigned char len);               //编码 ,电平1变为0011，电平0变为1100
 130          //void transCode(unsigned char *doData,unsigned char len);//解码，将接收到得数据还原
 131          void ComMode_1_Data(void);//发送边码1
 132          
 133          //开机函数
 134          void StartAll(void);
 135          //关机函数
 136          void StopAll(void);
 137          
 138          //t=1时，延迟100us左右
 139          void Delay3(unsigned int t)
 140          {
 141   1              unsigned int i,j;
 142   1              for(i=0;i<t;i++)                
 143   1              for(j=0;j<23;j++);
 144   1      }
 145          
 146          //init signal，发送编码信号前的起始信号，用于将接收机的自动增益打开
 147          void initsignal()
 148          {
 149   1              unsigned char k,k1;
 150   1              unsigned char mystartbuffer=0xaa;
 151   1              for(k1=0;k1<1;k1++)
 152   1              {
 153   2                      for(k=0;k<8;k++)
 154   2                      {
 155   3                              if((mystartbuffer&0x80)==0x80)//为1
 156   3                              {
 157   4                                      P10=0;
 158   4                                      Delay3(80);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 159   4                              }
 160   3                              else//为0的情况
 161   3                              {
 162   4                                      P10=0;
 163   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 164   4                              }
 165   3                              P10=1;//常态为高电平
 166   3                              mystartbuffer<<=1;
 167   3                              Delay3(150);//延时要大于2ms
 168   3                      }
 169   2                      mystartbuffer=0xaa;
 170   2                      Delay3(80);
 171   2              }
 172   1              P10=1;
 173   1      //      Delay3(80);
 174   1      }
 175          
 176          void main(void)
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 4   

 177          {
 178   1      //      unsigned int Check=0;//作为AD检测值     
 179   1      
 180   1              noVoice();
 181   1      //      InitUART();
 182   1              InitT0();
 183   1              InitT1();
 184   1      //      TI=0;
 185   1      //      RI=0;
 186   1      
 187   1              Turn=1;           //至高开关位
 188   1              ModeChange=1;
 189   1      
 190   1              BatteryControl=0;//电池在没有充满的情况下为低电平
 191   1      
 192   1              Moto=1; //关闭马达
 193   1      //      SwitchControl=0;         //开起接收机的控制端为高电平
 194   1      
 195   1      //      ES=1;
 196   1              ET0=1;
 197   1              ET1=1;
 198   1              PT1=1;//定时器1的中断优先级最高
 199   1              EA=1;
 200   1      
 201   1              myPwm();        //开发射机
 202   1      
 203   1      //      P1M1=0x02;
 204   1      //      P1M2=0x00;
 205   1              P10=1;
 206   1      //      P11=1;
 207   1              PAshutdown=0;             //开机时，将功放关闭
 208   1              
 209   1              Check=GetADCResult(6);//上电时，电池电量检测一次
 210   1              
 211   1      //开机直接启动附机
 212   1      //      SwitchControl=0;         //开起接收机的控制端为高电平
 213   1      
 214   1              PAshutdown=1;
 215   1              SC_Speech(3);            //车锁已打开
 216   1              Delay(100);
 217   1              PAshutdown=0;
 218   1                                                                                                                                                 
 219   1      //                                      StartAll();//开机给主机发送开机指令     
 220   1              commuFlag=1;//开启通信
 221   1              TurnFlag=1;
 222   1      
 223   1              alarmCount3=0;//清报警计数器
 224   1              alarmFlag3=0;//清报警标志
 225   1      
 226   1              while(1)
 227   1              {
 228   2      /*
 229   2                      if(Turn==0)
 230   2                      {
 231   2                              Delay(30);
 232   2                              if(Turn==0)
 233   2                              {
 234   2      //                              while(Turn==0);
 235   2                                      if(TurnFlag==0)          //说明是关机状态,则开机
 236   2                                      {
 237   2      //                                      SwitchControl=0;         //开起接收机的控制端为高电平
 238   2      
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 5   

 239   2                                              PAshutdown=1;
 240   2                                              SC_Speech(3);            //车锁已打开
 241   2                                              Delay(100);
 242   2                                              PAshutdown=0;
 243   2                                                                                                                                                                                 
 244   2      //                                      StartAll();//开机给主机发送开机指令     
 245   2                                              commuFlag=1;//开启通信
 246   2                                              TurnFlag=1;
 247   2      
 248   2                                              alarmCount3=0;//清报警计数器
 249   2                                              alarmFlag3=0;//清报警标志
 250   2                                      }
 251   2                                      else
 252   2                                      {        
 253   2                                              PAshutdown=1;
 254   2                                              SC_Speech(2);
 255   2                                              Delay(100);
 256   2                                              PAshutdown=0;
 257   2                                              Moto=1;//停止马达震动
 258   2      //                                      StopAll();
 259   2                                              commuFlag=0;//关闭通信
 260   2                                              TurnFlag=0;
 261   2      
 262   2                                              alarmCount3=0;//清报警计数器
 263   2                                              alarmFlag3=0;//清报警标志
 264   2      
 265   2      //                                      Check=GetADCResult(6);//电池电量检测
 266   2                                      }
 267   2                              }
 268   2                      }
 269   2      */
 270   2                      if((alarmFlag3==1)&&(alarmCount3<3))//编码3开始相应的报警
 271   2                      {
 272   3                              alarmCount3++;
 273   3      
 274   3                              PAshutdown=1;
 275   3                              SC_Speech(1);
 276   3                              Delay(150);
 277   3                              PAshutdown=0;
 278   3                              
 279   3                              Moto=0;//开震动
 280   3                              Delay(10);
 281   3                              Moto=1;
 282   3                      }
 283   2      //              if(alarmCount3>=2) //调节语音的段数        
 284   2      //              {
 285   2      //                      alarmCount3=0;//清报警计数器
 286   2      //                      alarmFlag3=0;//清报警标志
 287   2      //              }
 288   2      
 289   2                      if((alarmFlag4==1)&&(alarmCount4<3))//抬起开始相应的报警
 290   2                      {
 291   3                              alarmCount4++;
 292   3      
 293   3                              PAshutdown=1;
 294   3                              SC_Speech(5);
 295   3                              Delay(180);
 296   3                              
 297   3                              Moto=0;//开震动
 298   3                              Delay(10);
 299   3                              Moto=1;
 300   3                      }
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 6   

 301   2      //              if(alarmCount4>=1) //调节语音的段数        
 302   2      //              {
 303   2      //                      alarmCount4=0;//清报警计数器
 304   2      //                      alarmFlag4=0;//清报警标志
 305   2      //              }
 306   2      
 307   2                      if((alarmFlag5==1)&&(alarmCount5<3))//倒地开始相应的报警
 308   2                      {
 309   3                              alarmCount5++;
 310   3      
 311   3                              PAshutdown=1;
 312   3                              SC_Speech(4);
 313   3                              Delay(180);
 314   3      
 315   3                              Moto=0;//开震动
 316   3                              Delay(10);
 317   3                              Moto=1;
 318   3                      }
 319   2      //              if(alarmCount5>=1) //调节语音的段数        
 320   2      //              {
 321   2      //                      alarmCount5=0;//清报警计数器
 322   2      //                      alarmFlag5=0;//清报警标志
 323   2      //              }
 324   2      /*
 325   2                      if(Check>=0x377) //表示电池充包了
 326   2                      {
 327   2                              BatteryControl=1;//开漏模式，这样为高阻态       
 328   2                      }
 329   2                      else
 330   2                      {
 331   2                              BatteryControl=0;//电池在没有充满的情况下为低电平
 332   2                      }
 333   2      */
 334   2      /*
 335   2                      if((Check>=0x36f)&&(TurnFlag==1)&&(power1Flag==0))//设置比较电压，此处为4V,以4.2V为基准
 336   2                      {
 337   2                              PAshutdown=1;
 338   2                              SC_Speech(11);  //4V电量充足提示
 339   2                              Delay(130);
 340   2                              PAshutdown=0;
 341   2      
 342   2                              power1Flag=1;
 343   2                              power2Flag=0;
 344   2                              power3Flag=0;
 345   2                              power4Flag=0;
 346   2                      }
 347   2                  else if((Check<0x36f)&&(Check>=0x365)&&(TurnFlag==1)&&(power2Flag==0))
 348   2                      {
 349   2                              PAshutdown=1;
 350   2                              SC_Speech(10);  //3.8V电量充足提示
 351   2                              Delay(130);
 352   2                              PAshutdown=0;
 353   2              
 354   2                              power2Flag=1;
 355   2                              power1Flag=0;
 356   2                              power3Flag=0;
 357   2                              power4Flag=0;
 358   2                      }
 359   2                      else if((Check<0x365)&&(Check>=0x360)&&(TurnFlag==1)&&(power3Flag==0))
 360   2                      {
 361   2                              PAshutdown=1;
 362   2                              SC_Speech(9);  //3.6V电量充足提示
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 7   

 363   2                              Delay(130);
 364   2                              PAshutdown=0;
 365   2      
 366   2                              power3Flag=1;
 367   2                              power1Flag=0;
 368   2                              power2Flag=0;
 369   2                              power4Flag=0;
 370   2                      }
 371   2                      else if((Check<0x360)&&(TurnFlag==1)&&(power4Flag==0))
 372   2                      {
 373   2                              PAshutdown=1;
 374   2                              SC_Speech(8);  //低于3.6v电量充足提示
 375   2                              Delay(130);
 376   2                              PAshutdown=0;
 377   2      
 378   2                              power4Flag=1;
 379   2                              power1Flag=0;
 380   2                              power2Flag=0;
 381   2                              power3Flag=0;
 382   2                      }
 383   2      */
 384   2              }
 385   1      }
 386          
 387          void timeT1() interrupt 3 //定时器1中断接收数据
 388          {
 389   1      //      unsigned int newAddr=0;
 390   1              TH1=timer1H;//重装载
 391   1              TL1=timer1L;
 392   1      
 393   1              if(P11==0)//正常情况为高电平,有低电平说明有信号
 394   1              {
 395   2                      DataBetween++;
 396   2                      ComFlag=0;
 397   2                      if(DataBetween==150)//低电平持续的最大时间      
 398   2                      {
 399   3                              DataBetween=0;
 400   3                      }
 401   2              }
 402   1              else//为高电平了
 403   1              {
 404   2                      if(ComFlag==0)//说明有一个低电平
 405   2                      {
 406   3                              ComFlag=1;
 407   3      //                      RecData<<=1;
 408   3      
 409   3                              if((DataBetween>60)&&(DataBetween<=100))//低电平持续的时间小于3ms，则为0
 410   3                              {
 411   4                                      RecData<<=1;
 412   4                                      RecData &= 0xfe;
 413   4                                      DataTime++;
 414   4                                      T1highcount=0;
 415   4                              }
 416   3                              if(DataBetween>100)//低电平持续的时间大于4.5ms，则为1
 417   3                              {
 418   4                                      RecData<<=1;
 419   4                                      RecData |= 0x01;
 420   4                                      DataTime++;
 421   4                                      T1highcount=0;
 422   4                              }
 423   3                              else
 424   3                              {
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 8   

 425   4                                      T1highcount++;  
 426   4                              }
 427   3      
 428   3                              DataBetween=0;
 429   3      //                              DataTime++;
 430   3                      }
 431   2                      else
 432   2                      {
 433   3                              T1highcount++;
 434   3                              if(T1highcount>=120)
 435   3                              {
 436   4                                      DataTime=0;
 437   4                                      ComFlag=1;
 438   4                                      count=0;
 439   4                              }               
 440   3                      }
 441   2              }
 442   1      
 443   1              if(DataTime==8)//说明一个字节的数据已经接受完全
 444   1              {
 445   2                      DataTime=0;
 446   2                      myTxRxData[count]=RecData;
 447   2                      if(count==0&&myTxRxData[0]==CmdHead)
 448   2                      {
 449   3                              count=1;
 450   3                      }
 451   2                      else if(count==1&&myTxRxData[1]==MyAddress)
 452   2                      {
 453   3                              count=2;
 454   3                      }
 455   2                      else if(count>=2&&count<=5)
 456   2                      {
 457   3                              count++;
 458   3                      }
 459   2                      else if(count==6)
 460   2                      {
 461   3                              receiveFlag=1;
 462   3                              count=0;
 463   3                      }
 464   2                      else 
 465   2                      {
 466   3                              count=0;
 467   3                      }
 468   2              }
 469   1      
 470   1              if(receiveFlag==1)      //说明接收到了数据，开始处理
 471   1              {
 472   2                      receiveFlag=0;  //清接收标志
 473   2      
 474   2                      switch(myTxRxData[2])//解析指令
 475   2                      {
 476   3                              case ComMode_1://接收到的是主机发送过来的编码1的信号，说明主机在3M内，是正常的
 477   3                              {       
 478   4                                      TestFlag=0;//正常情况，清超时标志
 479   4      
 480   4                                      alarmCount3=0;//清报警计数器
 481   4                                      alarmFlag3=0;//清报警标志
 482   4      
 483   4                                      alarmCount4=0;//清报警计数器
 484   4                                      alarmFlag4=0;//清报警标志
 485   4      
 486   4                                      alarmCount5=0;//清报警计数器
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 9   

 487   4                                      alarmFlag5=0;//清报警标志
 488   4                              }
 489   3                              break;
 490   3                      
 491   3                              case ComMode_3:
 492   3                              {
 493   4                                      TestFlag=0;//清超时标志                         
 494   4                                      alarmFlag3=1;
 495   4      
 496   4                                      alarmCount4=0;//清报警计数器
 497   4                                      alarmFlag4=0;//清报警标志
 498   4                                      alarmCount5=0;//清报警计数器
 499   4                                      alarmFlag5=0;//清报警标志
 500   4                              }
 501   3                              break;
 502   3                      
 503   3                              case ComMode_4://留作抬起信号使用
 504   3                              {
 505   4                                      TestFlag=0;//清超时标志 
 506   4                                      alarmFlag4=1;//抬起报警
 507   4      
 508   4                                      alarmCount3=0;//清报警计数器
 509   4                                      alarmFlag3=0;//清报警标志
 510   4                                      alarmCount5=0;//清报警计数器
 511   4                                      alarmFlag5=0;//清报警标志
 512   4                              }
 513   3                              break;
 514   3      
 515   3                              case ComMode_5://留作倒地信号使用
 516   3                              {
 517   4                                      TestFlag=0;//清超时标志
 518   4                                      alarmFlag5=1;   //倒地报警
 519   4      
 520   4                                      alarmCount3=0;//清报警计数器
 521   4                                      alarmFlag3=0;//清报警标志
 522   4                                      alarmCount4=0;//清报警计数器
 523   4                                      alarmFlag4=0;//清报警标志
 524   4      
 525   4                              }
 526   3                              break;
 527   3                      }
 528   2              }
 529   1      }
 530          
 531          void time0() interrupt 1        //作为整个系统自己的时钟
 532          {
 533   1              TH0=timer0H;//重装载
 534   1              TL0=timer0L;
 535   1      
 536   1              time0Count_3++;
 537   1      
 538   1              if(time0Count_3>=60)//串口每1S发送一次的数据的时间标志
 539   1              {
 540   2                      Check=GetADCResult(6);//电池电量检测
 541   2      
 542   2                      if(commuFlag==1)//说明开启了通信
 543   2                      {
 544   3                              ComMode_1_Data();//发送模式1信号
 545   3                              TestFlag++;
 546   3                              
 547   3                              if(TestFlag>=4)//说明已经出了300M了。收不到任何信号了，要做报警
 548   3                              {
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 10  

 549   4                                      TestFlag=5;
 550   4                                      //加入相应处理代码      
 551   4                              }
 552   3                      }
 553   2                      time0Count_3=0;
 554   2              }
 555   1      }
 556          
 557          void StartAll() //发送开始信号
 558          {
 559   1              unsigned char i,n;
 560   1      
 561   1              myTxRxData[0]=CmdHead;
 562   1              myTxRxData[1]=MyAddress;
 563   1              myTxRxData[2]=CmdStart;
 564   1              myTxRxData[3]=0x00;
 565   1              myTxRxData[4]=0x00;
 566   1              myTxRxData[5]=0x00;
 567   1              myTxRxData[6]=0x00;
 568   1              
 569   1              initsignal();
 570   1      
 571   1              for(i=0;i<7;i++)
 572   1              {
 573   2                      for(n=0;n<8;n++)
 574   2                      {
 575   3                              if((myTxRxData[i]&0x80)==0x80)//为1
 576   3                              {
 577   4                                      P10=0;
 578   4                                      Delay3(120);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 579   4                              }
 580   3                              else//为0的情况
 581   3                              {
 582   4                                      P10=0;
 583   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 584   4                              }
 585   3                              P10=1;//常态为高电平
 586   3                              myTxRxData[i]<<=1;
 587   3                              Delay3(50);//延时要大于2ms
 588   3                      }
 589   2              }
 590   1      }
 591          
 592          void StopAll() //发送停止信号
 593          {
 594   1              unsigned char i,n;
 595   1      
 596   1              myTxRxData[0]=CmdHead;
 597   1              myTxRxData[1]=MyAddress;
 598   1              myTxRxData[2]=CmdStop;
 599   1              myTxRxData[3]=0x00;
 600   1              myTxRxData[4]=0x00;
 601   1              myTxRxData[5]=0x00;
 602   1              myTxRxData[6]=0x00;
 603   1      
 604   1              initsignal();
 605   1      
 606   1              for(i=0;i<7;i++)
 607   1              {
 608   2                      for(n=0;n<8;n++)
 609   2                      {
 610   3                              if((myTxRxData[i]&0x80)==0x80)//为1
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 11  

 611   3                              {
 612   4                                      P10=0;
 613   4                                      Delay3(120);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 614   4                              }
 615   3                              else//为0的情况
 616   3                              {
 617   4                                      P10=0;
 618   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 619   4                              }
 620   3                              P10=1;//常态为高电平
 621   3                              myTxRxData[i]<<=1;
 622   3                              Delay3(50);//延时要大于2ms
 623   3                      }
 624   2              }
 625   1      }
 626          
 627          void ComMode_1_Data()//发送边码1
 628          {
 629   1              unsigned char i,n;
 630   1      
 631   1              ModeControl_1=0;//30M发射功率                           
 632   1              tran_en=1;      //打开无线发射机
 633   1              myTxRxData[0]=CmdHead;
 634   1              myTxRxData[1]=MyAddress;
 635   1              myTxRxData[2]=ComMode_1;
 636   1              myTxRxData[3]=0x00;
 637   1              myTxRxData[4]=0x00;
 638   1              myTxRxData[5]=0x00;
 639   1              myTxRxData[6]=0x00;
 640   1      
 641   1              initsignal();
 642   1      
 643   1              for(i=0;i<7;i++)
 644   1              {
 645   2                      for(n=0;n<8;n++)
 646   2                      {
 647   3                              if((myTxRxData[i]&0x80)==0x80)//为1
 648   3                              {
 649   4                                      P10=0;
 650   4                                      Delay3(120);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 651   4                              }
 652   3                              else//为0的情况
 653   3                              {
 654   4                                      P10=0;
 655   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 656   4                              }
 657   3                              P10=1;//常态为高电平
 658   3                              myTxRxData[i]<<=1;
 659   3                              Delay3(50);//延时要大于2ms
 660   3                      }
 661   2              }
 662   1              tran_en=0;
 663   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    981    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     60       8
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.01   NEWSLAVE                                                              07/16/2013 11:01:49 PAGE 12  

   BIT SIZE         =     15    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
