C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NEWSLAVE
OBJECT MODULE PLACED IN .\out\newSlave.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE newSlave.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\listing\newSlave.lst) OBJECT(.\out\newSlave.obj)

line level    source

   1          #include"N79E81x.h"
   2          #include<intrins.h>
   3          #include"AD.h"
   4          #include"UART.h"
   5          #include"T0.h"
   6          #include"voice.h"
   7          #include"pwm.h"
   8          #include"T1.h"
   9          
  10          //定义通信命令
  11          #define CmdStart 0x00 //开机命令
  12          #define CmdStop 0x01  //关机命令
  13          #define ComMode_1 0xc1 //通信模式1 
  14          #define ComMode_2 0xc2 //通信模式2
  15          #define ComMode_3 0xc3 //通信模式3
  16          #define ComMode_4 0xc4 //抬起指令
  17          #define ComMode_5 0xc5//倒地指令
  18          #define ComMode_6 0xc6//充电已满指令
  19          #define Succeed 0xce  //通信成功
  20          #define Wrong 0xff    //通信失败
  21          #define CmdHead 0xc8
  22          #define CmdHead1 0x33 //数据帧的首部1, 00110011,11
  23          #define CmdHead2 0xcc //数据帧的首部2,11001100,00
  24          #define CmdHead3 0x3c //数据帧的首部3,11000011,01
  25          #define CmdHead4 0xcc //数据帧的首部4,11001100,00
  26          #define MyAddress 0xe0
  27          #define MyAddress1 0x33 //本机地址1, 00110011,11
  28          #define MyAddress2 0x3c //本机地址2, 11000011,01
  29          #define MyAddress3 0xcc //本机地址3,11001100,00
  30          #define MyAddress4 0xcc //本机地址4,11001100,00
  31          
  32          sbit ModeControl_1=P2^6;        //发射机模式控制,0为大功率，1为小功率
  33          sbit Moto=P2^4;                         //振动器控制，0振动，1不振动
  34          sbit receive_en=P1^3;           //接收机使能，1打开接收机，0关闭接收机，要加上拉电阻
  35          sbit tran_en=P2^7;                      //发射机使能，1打开发射机，0关闭发射机
  36          sbit PAshutdown=P1^4;           //功放开关控制，1为打开功放，0为关闭功放
  37          
  38          
  39          bit ModeFlag=0;                         //模式选择位，0则用模式1,1则用模式2
  40          bit receiveFlag=0;                      //接收到数据标志
  41          bit commuFlag=0;                        //开启通信标志
  42          
  43          bit alarmFlag2=0;                       //是否继续报警标志
  44          bit alarmFlag3=0;                       //是否继续报警标志
  45          bit alarmFlag4=0;                       //抬起报警
  46          bit alarmFlag5=0;                       //倒地报警
  47          unsigned int alarmCount2=0;     //报警2循环次数
  48          unsigned int alarmCount3=0;     //报警3循环次数
  49          unsigned int alarmCount4=0;     //抬起报警循环次数
  50          unsigned int alarmCount5=0;     //倒地报警循环次数
  51          
  52          unsigned char voiceFlag=0;      //声音循环开关 
  53          
  54          unsigned char dataFirst=0;      //用于存储上次编码类型
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 2   

  55          
  56          unsigned char count=0;          //串口接收部分的计数器
  57           
  58          unsigned int time0Count_3=0;//作为串口每秒主辅机的信息交互时钟
  59          
  60          unsigned int lastAddr=0;        //上一次接收到的编码的地址
  61          unsigned int TestFlag=0;        //1、2、3分别为每1S后的计数，在串口的成功指令里会执行将去归零的操作
  62                                                  //如果连续3次都没有归零，则说明不在场了
  63          
  64          //作为接收和发送的缓存区
  65          unsigned char TxRxBuf[28]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
             -,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  66          //一个头字节，一个地址字节，一个命令字节，两个编码地址字节，两个编码
  67          unsigned char myTxRxData[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};//处理完后的通信数据的缓冲区
  68          unsigned char myTxRxData2[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};       //接收数据的缓存
  69          
  70          unsigned int Check=0;           //作为AD检测值
  71          bit checkFlag=0;                        //电量检测标志
  72           
  73          unsigned char DataBetween=0;    //作为接收数据的中间变量
  74          unsigned char RecData=0;                //接收到的数据
  75          unsigned char DataTime=0;               //作为接收的数据的移位次数计数
  76          bit ComFlag=1;                                  //做上升沿的一个标志
  77          unsigned char T1highcount=0;    //定时器T1在没有信号到来的时候，对高电平计数，一旦超过某个值，则将Datatime清0
  78          
  79          bit ADCcheck=0;                 //置1时，执行一次电量转换，执行完后，将其置0
  80          bit sendcomm1=0;                //置1时，执行一次发送编码1，执行完后，将其置0
  81          bit sendspeech1=0;              //置1时，执行一次语音提示，表示充电已满
  82          unsigned char speech1_count=0;  
  83          unsigned char powerflag=1;              //电池电位的标记，1表示现在电池是满的，0表示还没满。
  84          
  85          
  86          
  87          void ComMode_1_Data(void);              //发送编码1
  88          
  89          void Delay3(unsigned int t)             //t=1时，延迟100us左右
  90          {
  91   1              unsigned int i,j;
  92   1              for(i=0;i<t;i++)                
  93   1              for(j=0;j<23;j++);
  94   1      }
  95          
  96          void initsignal()                               //init signal，发送编码信号前的起始信号，用于将接收机的自动增益打开
  97          {
  98   1              unsigned char k,k1;
  99   1              unsigned char mystartbuffer=0xaa;
 100   1              for(k1=0;k1<1;k1++)
 101   1              {
 102   2                      for(k=0;k<8;k++)
 103   2                      {
 104   3                              if((mystartbuffer&0x80)==0x80)//为1
 105   3                              {
 106   4                                      P10=0;
 107   4                                      Delay3(80);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 108   4                              }
 109   3                              else//为0的情况
 110   3                              {
 111   4                                      P10=0;
 112   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 113   4                              }
 114   3                              P10=1;//常态为高电平
 115   3                              mystartbuffer<<=1;
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 3   

 116   3                              Delay3(150);//延时要大于2ms
 117   3                      }
 118   2                      mystartbuffer=0xaa;
 119   2                      Delay3(80);
 120   2              }
 121   1              P10=1;
 122   1      }
 123          
 124          void main(void)
 125          {
 126   1              noVoice();
 127   1              InitT0();
 128   1              InitT1();
 129   1              Moto=1;                 //关闭马达
 130   1      
 131   1              ET0=1;
 132   1              ET1=1;
 133   1              PT1=1;                  //定时器1的中断优先级最高
 134   1              EA=1;
 135   1      
 136   1              myPwm();                //开发射机
 137   1              P10=1;
 138   1              PAshutdown=0;                   //开机时，将功放关闭
 139   1              
 140   1              Check=GetADCResult(6);  //上电时，电池电量检测一次
 141   1              
 142   1              commuFlag=1;                    //开启通信
 143   1              alarmCount3=0;                  //清报警计数器
 144   1              alarmFlag3=0;                   //清报警标志
 145   1      
 146   1              while(1)
 147   1              {
 148   2                      if(alarmFlag3==1)               //编码3开始相应的报警
 149   2                      {
 150   3                              if(alarmCount3<1)
 151   3                              {
 152   4                                      PAshutdown=1;
 153   4                                      SC_Speech(5);
 154   4                                      Delay(150);
 155   4                                      SC_Speech(6);
 156   4                                      Delay(80);
 157   4                                      SC_Speech(7);
 158   4                                      Delay(120);
 159   4                                      PAshutdown=0;
 160   4                                      
 161   4                                      Moto=0;                         
 162   4                                      Delay(10);
 163   4                                      Moto=1;
 164   4                                      alarmCount3++;
 165   4                              }
 166   3                      }
 167   2      
 168   2                      if(alarmFlag4==1)               //抬起开始相应的报警
 169   2                      {
 170   3                              if(alarmCount4<1)
 171   3                              {
 172   4                                      PAshutdown=1;
 173   4                                      SC_Speech(4);
 174   4                                      Delay(180);
 175   4                                      
 176   4                                      Moto=0;
 177   4                                      Delay(10);
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 4   

 178   4                                      Moto=1;
 179   4                                      alarmCount4++;
 180   4                              }
 181   3                      }
 182   2      
 183   2                      if(alarmFlag5==1)//倒地开始相应的报警
 184   2                      {
 185   3                              if(alarmCount5<1)
 186   3                              {
 187   4                                      PAshutdown=1;
 188   4                                      SC_Speech(8);
 189   4                                      Delay(180);
 190   4              
 191   4                                      Moto=0;//开震动
 192   4                                      Delay(10);
 193   4                                      Moto=1;
 194   4                                      alarmCount5++;
 195   4                              }
 196   3                      }
 197   2      
 198   2                      if(ADCcheck==1)                         //每个3s检测一次电量，如果电池满的就检测是否低了，如果是不满的就检测是否充满。
 199   2                      {
 200   3                              Check=GetADCResult(6);  //电池电量检测
 201   3                              ADCcheck=0;
 202   3                              
 203   3                              if((powerflag==1)&&(Check<=0x35a))
 204   3                              {
 205   4                                      powerflag=0;
 206   4                                      PAshutdown=1;
 207   4                                      SC_Speech(9);   //电压不充足提示
 208   4                                      Delay(120);
 209   4                                      PAshutdown=0;
 210   4                              }
 211   3                              else if((powerflag==0)&&(Check>=0x377))
 212   3                              {
 213   4                                      powerflag=1;
 214   4                                      PAshutdown=1;
 215   4                                      SC_Speech(2);   //电压充足提示
 216   4                                      Delay(120);
 217   4                                      PAshutdown=0;
 218   4                              }       
 219   3                      }
 220   2      
 221   2                      if(sendcomm1==1)
 222   2                      {
 223   3                              receive_en=0;           //打开接收机
 224   3                              ComMode_1_Data();       //发送模式1信号
 225   3                              receive_en=1;           //打开接收机
 226   3                              sendcomm1=0;
 227   3                      }
 228   2      
 229   2                      if(sendspeech1==1)
 230   2                      {
 231   3                              PAshutdown=1;
 232   3                              SC_Speech(2);  
 233   3                              Delay(80);
 234   3                              SC_Speech(3);  
 235   3                              Delay(80);
 236   3                              PAshutdown=0;
 237   3                              sendspeech1=0;
 238   3                      }
 239   2              }
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 5   

 240   1      }
 241          
 242          void timeT1() interrupt 3                               //定时器1中断接收数据
 243          {
 244   1              TH1=timer1H;                                            //重装载
 245   1              TL1=timer1L;
 246   1      
 247   1              if(P11==0)                                                      //正常情况为高电平,有低电平说明有信号
 248   1              {
 249   2                      DataBetween++;
 250   2                      ComFlag=0;
 251   2                      if(DataBetween==150)                    //低电平持续的最大时间  
 252   2                      {
 253   3                              DataBetween=0;
 254   3                      }
 255   2              }
 256   1              else//为高电平了
 257   1              {
 258   2                      if(ComFlag==0)//说明有一个低电平
 259   2                      {
 260   3                              ComFlag=1;
 261   3      //                      RecData<<=1;
 262   3      
 263   3                              if((DataBetween>60)&&(DataBetween<=100))//低电平持续的时间小于3ms，则为0
 264   3                              {
 265   4                                      RecData<<=1;
 266   4                                      RecData &= 0xfe;
 267   4                                      DataTime++;
 268   4                                      T1highcount=0;
 269   4                              }
 270   3                              if(DataBetween>100)//低电平持续的时间大于4.5ms，则为1
 271   3                              {
 272   4                                      RecData<<=1;
 273   4                                      RecData |= 0x01;
 274   4                                      DataTime++;
 275   4                                      T1highcount=0;
 276   4                              }
 277   3                              else
 278   3                              {
 279   4                                      T1highcount++;  
 280   4                              }
 281   3      
 282   3                              DataBetween=0;
 283   3                      }
 284   2                      else
 285   2                      {
 286   3                              T1highcount++;
 287   3                              if(T1highcount>=120)
 288   3                              {
 289   4                                      DataTime=0;
 290   4                                      ComFlag=1;
 291   4                                      count=0;
 292   4                              }               
 293   3                      }
 294   2              }
 295   1      
 296   1              if(DataTime==8)//说明一个字节的数据已经接受完全
 297   1              {
 298   2                      DataTime=0;
 299   2                      myTxRxData2[count]=RecData;
 300   2                      if(count==0&&myTxRxData2[0]==CmdHead)
 301   2                      {
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 6   

 302   3                              count=1;
 303   3                      }
 304   2                      else if(count==1&&myTxRxData2[1]==MyAddress)
 305   2                      {
 306   3                              count=2;
 307   3                      }
 308   2                      else if(count==2)
 309   2                      {
 310   3                              receiveFlag=1;
 311   3                              count=0;
 312   3                      }
 313   2                      else 
 314   2                      {
 315   3                              count=0;
 316   3                      }
 317   2      
 318   2      /*
 319   2                      else if(count>=2&&count<=5)
 320   2                      {
 321   2                              count++;
 322   2                      }
 323   2                      else if(count==6)
 324   2                      {
 325   2                              receiveFlag=1;
 326   2                              count=0;
 327   2                      }
 328   2                      else 
 329   2                      {
 330   2                              count=0;
 331   2                      }
 332   2      */
 333   2              }
 334   1      
 335   1              if(receiveFlag==1)      //说明接收到了数据，开始处理
 336   1              {
 337   2                      receiveFlag=0;  //清接收标志
 338   2                      receive_en=0;                   //关闭接收机
 339   2                      switch(myTxRxData2[2])//解析指令
 340   2                      {
 341   3                              case ComMode_1://接收到的是主机发送过来的编码1的信号，说明主机在3M内，是正常的
 342   3                              {       
 343   4                                      TestFlag=0;//正常情况，清超时标志
 344   4      
 345   4                                      alarmCount3=0;//清报警计数器
 346   4                                      alarmFlag3=0;//清报警标志
 347   4      
 348   4                                      alarmCount4=0;//清报警计数器
 349   4                                      alarmFlag4=0;//清报警标志
 350   4      
 351   4                                      alarmCount5=0;//清报警计数器
 352   4                                      alarmFlag5=0;//清报警标志
 353   4      
 354   4                                      Moto=0;//开震动
 355   4                                      Delay(10);
 356   4                                      Moto=1;
 357   4                              }
 358   3                              break;
 359   3                      
 360   3                              case ComMode_3:
 361   3                              {
 362   4                                      TestFlag=0;//清超时标志                         
 363   4                                      alarmFlag3=1;
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 7   

 364   4      
 365   4                                      alarmCount4=0;//清报警计数器
 366   4                                      alarmFlag4=0;//清报警标志
 367   4                                      alarmCount5=0;//清报警计数器
 368   4                                      alarmFlag5=0;//清报警标志
 369   4                              }
 370   3                              break;
 371   3                      
 372   3                              case ComMode_4://留作抬起信号使用
 373   3                              {
 374   4                                      TestFlag=0;//清超时标志 
 375   4                                      alarmFlag4=1;//抬起报警
 376   4      
 377   4                                      alarmCount3=0;//清报警计数器
 378   4                                      alarmFlag3=0;//清报警标志
 379   4                                      alarmCount5=0;//清报警计数器
 380   4                                      alarmFlag5=0;//清报警标志
 381   4                              }
 382   3                              break;
 383   3      
 384   3                              case ComMode_5://留作倒地信号使用
 385   3                              {
 386   4                                      TestFlag=0;//清超时标志
 387   4                                      alarmFlag5=1;   //倒地报警
 388   4      
 389   4                                      alarmCount3=0;//清报警计数器
 390   4                                      alarmFlag3=0;//清报警标志
 391   4                                      alarmCount4=0;//清报警计数器
 392   4                                      alarmFlag4=0;//清报警标志
 393   4                              }
 394   3                              break;
 395   3      
 396   3                              case ComMode_6://留作倒地信号使用
 397   3                              {
 398   4                                      sendspeech1=1;
 399   4                              }
 400   3                              break;
 401   3                      }
 402   2              }
 403   1      }
 404          
 405          void time0() interrupt 1        //作为整个系统自己的时钟
 406          {
 407   1              TH0=timer0H;//重装载
 408   1              TL0=timer0L;
 409   1      
 410   1              time0Count_3++;
 411   1      
 412   1              if(time0Count_3>=60)            //串口每1S发送一次的数据的时间标志
 413   1              {
 414   2                      ADCcheck=1;
 415   2                      if(commuFlag==1)                //说明开启了通信
 416   2                      {
 417   3                              TestFlag++;
 418   3                              sendcomm1=1;
 419   3                              if(TestFlag>=4)         //说明已经出了300M了。收不到任何信号了，要做报警
 420   3                              {
 421   4                                      TestFlag=5;
 422   4                              }
 423   3                      }
 424   2                      time0Count_3=0;
 425   2              }
C51 COMPILER V9.01   NEWSLAVE                                                              08/20/2013 11:10:46 PAGE 8   

 426   1      }
 427          
 428          void ComMode_1_Data()                   //发送编码1
 429          {
 430   1              unsigned char i,n;
 431   1      
 432   1              ModeControl_1=0;//30M发射功率                           
 433   1              tran_en=1;      //打开无线发射机
 434   1              myTxRxData[0]=CmdHead;
 435   1              myTxRxData[1]=MyAddress;
 436   1              myTxRxData[2]=ComMode_1;
 437   1      /*      myTxRxData[3]=0x00;
 438   1              myTxRxData[4]=0x00;
 439   1              myTxRxData[5]=0x00;
 440   1              myTxRxData[6]=0x00;
 441   1      */
 442   1              initsignal();
 443   1      
 444   1              for(i=0;i<3;i++)
 445   1              {
 446   2                      for(n=0;n<8;n++)
 447   2                      {
 448   3                              if((myTxRxData[i]&0x80)==0x80)//为1
 449   3                              {
 450   4                                      P10=0;
 451   4                                      Delay3(120);//延时4.5ms以上，由于定时器占用问题，只能用这种延时来实现
 452   4                              }
 453   3                              else//为0的情况
 454   3                              {
 455   4                                      P10=0;
 456   4                                      Delay3(80);//延时2ms，由于定时器占用问题，只能用这种延时来实现
 457   4                              }
 458   3                              P10=1;//常态为高电平
 459   3                              myTxRxData[i]<<=1;
 460   3                              Delay3(50);//延时要大于2ms
 461   3                      }
 462   2              }
 463   1              tran_en=0;
 464   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    939    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     67       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
