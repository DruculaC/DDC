C51 COMPILER V9.51   TIMER                                                                 11/14/2013 10:54:22 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Timer.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             Timer.c (v1.00)
   3             
   4             Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "Other.h"
  13          
  14          // ------ Public variable declarations -----------------------------
  15          bit fell_alarm_flag = 0;         //µ¹µØ±¨¾¯±êÖ¾
  16          tByte fell_alarm_count = 0;      //µ¹µØ±¨¾¯Ñ­»·´ÎÊý
  17          
  18          bit raised_alarm_flag = 0;    //Ì§Æð±¨¾¯±êÖ¾
  19          tByte raised_alarm_count = 0; //Ì§Æð±¨¾¯Ñ­»·´ÎÊý
  20          
  21          bit stolen_alarm_flag = 0;    //±»µÁ±¨¾¯±êÖ¾
  22          tWord stolen_alarm_count = 0; //±»µÁ±¨¾¯Ñ­»·´ÎÊý
  23          
  24          bit transmit_comm1_flag = 0;     //Ã¿¸ôÒ»¶ÎÊ±¼ä½«ÆäÖÃ1£¬ÔòÔÚmainº¯ÊýÖÐ·¢ÉäÊý¾Ý£¬¾Í²»»áÓ°Ïìtimer0µÄ¼ÆÊ±£¬·¢ÉäÍ
             -êºó½«ÆäÖÃ0.
  25          bit comm_whole_control = 0;      //Í¨ÐÅ×Ü¿ª¹Ø£¬0¹Ø±ÕÍ¨ÐÅ£¬1´ò¿ªÍ¨ÐÅ
  26          bit battery_check = 0;           //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎµçÁ¿×ª»»£¬Ö´ÐÐÍêºó£¬½«ÆäÖÃ0
  27          bit Host_battery_high_flag = 0;     //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎÓïÒôÌáÊ¾£¬±íÊ¾³äµçÒÑÂú
  28          
  29          
  30          // ------ Private variable definitions -----------------------------
  31          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;  //¶¨Ê±Æ÷0ºÍ1µÄ¶¨Ê±Êý¾Ý
  32          
  33          tWord timer0_count = 0;       //ÓÃÀ´¼ÆÊýtimer0µÄ´ÎÊý£¬Ã»Òç³öÒ»´Î¾Í¼Ó1£¬Ïàµ±ÓÚ¼ÆÊ±
  34          tByte leave_count = 0;           //Ã¿¸ô3s¼Ó1£¬Èç¹ûÖ÷»úÓ¦´ðÕýÈ·£¬Ôò½«ÆäÇåÁã
  35          tByte received_data_buffer[7] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //½ÓÊÕÊý¾Ý»º´æ
  36          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  37          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  38          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  39          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  40          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  41          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  42          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  43          
  44          /*------------------------------------------------------------------
  45             timerT0()
  46             ¶¨Ê±Æ÷0Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  47          --------------------------------------------------------------------*/
  48          
  49          void timer0() interrupt interrupt_timer_0_overflow
  50          {
  51   1         TH0 = timer0_8H;
C51 COMPILER V9.51   TIMER                                                                 11/14/2013 10:54:22 PAGE 2   

  52   1         TL0 = timer0_8L;
  53   1      
  54   1         timer0_count++;
  55   1      
  56   1         if(timer0_count >= 60)     //´®¿ÚÃ¿1S·¢ËÍÒ»´ÎµÄÊý¾ÝµÄÊ±¼ä±êÖ¾
  57   1         {
  58   2            battery_check = 1;
  59   2            if(comm_whole_control == 1)      //ËµÃ÷¿ªÆôÁËÍ¨ÐÅ
  60   2            {
  61   3               leave_count++;
  62   3               transmit_comm1_flag = 1;
  63   3               if(leave_count >= 4)    //ËµÃ÷ÒÑ¾­³öÁË300MÁË¡£ÊÕ²»µ½ÈÎºÎÐÅºÅÁË£¬Òª×ö±¨¾¯
  64   3               {
  65   4                  leave_count = 5;
  66   4               }
  67   3            }
  68   2            timer0_count = 0;
  69   2         }
  70   1      
  71   1         if(stolen_alarm_count >= 2)
  72   1         {
  73   2            stolen_alarm_count++;
  74   2            if(stolen_alarm_count == 1800)
  75   2            {
  76   3               stolen_alarm_count = 0;
  77   3               stolen_alarm_flag = 0;
  78   3            }
  79   2         }
  80   1      }
  81          
  82          /*------------------------------------------------------------------
  83             timerT1()
  84             ¶¨Ê±Æ÷1Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  85          --------------------------------------------------------------------*/
  86             
  87          void timerT1() interrupt interrupt_timer_1_overflow            //¶¨Ê±Æ÷1ÖÐ¶Ï½ÓÊÕÊý¾Ý
  88          {
  89   1         TH1 = timer1_8H;              //ÖØ×°ÔØ
  90   1         TL1 = timer1_8L;
  91   1      
  92   1         if(receive_wire == 0)                     //Õý³£Çé¿öÎª¸ßµçÆ½,ÓÐµÍµçÆ½ËµÃ÷ÓÐÐÅºÅ
  93   1         {
  94   2            receive_LV_count++;
  95   2            receive_wire_flag=0;
  96   2            if(receive_LV_count==80)         //µÍµçÆ½³ÖÐøµÄ×î´óÊ±¼ä  
  97   2            {
  98   3               receive_LV_count=0;
  99   3            }
 100   2         }
 101   1         else//Îª¸ßµçÆ½ÁË
 102   1         {
 103   2            if(receive_wire_flag==0)//ËµÃ÷ÓÐÒ»¸öµÍµçÆ½
 104   2            {
 105   3               receive_wire_flag=1;
 106   3      //       one_receive_byte<<=1;
 107   3      
 108   3               if((receive_LV_count>35)&&(receive_LV_count<=50))//µÍµçÆ½³ÖÐøµÄÊ±¼äÐ¡ÓÚ3ms£¬ÔòÎª0
 109   3               {
 110   4                  one_receive_byte<<=1;
 111   4                  one_receive_byte &= 0xfe;
 112   4                  one_receive_byte_count++;
 113   4                  receive_HV_count=0;
C51 COMPILER V9.51   TIMER                                                                 11/14/2013 10:54:22 PAGE 3   

 114   4               }
 115   3               if(receive_LV_count>50)//µÍµçÆ½³ÖÐøµÄÊ±¼ä´óÓÚ4.5ms£¬ÔòÎª1
 116   3               {
 117   4                  one_receive_byte<<=1;
 118   4                  one_receive_byte |= 0x01;
 119   4                  one_receive_byte_count++;
 120   4                  receive_HV_count=0;
 121   4               }
 122   3               else
 123   3               {
 124   4                  receive_HV_count++;  
 125   4               }
 126   3      
 127   3               receive_LV_count=0;
 128   3            }
 129   2            else
 130   2            {
 131   3               receive_HV_count++;
 132   3               if(receive_HV_count>=60)
 133   3               {
 134   4                  one_receive_byte_count=0;
 135   4                  receive_wire_flag=1;
 136   4                  data_count=0;
 137   4               }     
 138   3            }
 139   2         }
 140   1      
 141   1         if(one_receive_byte_count==8)//ËµÃ÷Ò»¸ö×Ö½ÚµÄÊý¾ÝÒÑ¾­½ÓÊÜÍêÈ«
 142   1         {
 143   2            one_receive_byte_count=0;
 144   2            received_data_buffer[data_count]=one_receive_byte;
 145   2            if(data_count==0&&received_data_buffer[0]==CmdHead)
 146   2            {
 147   3               data_count=1;
 148   3            }
 149   2            else if(data_count==1&&received_data_buffer[1]==MyAddress)
 150   2            {
 151   3               data_count=2;
 152   3            }
 153   2            else if(data_count==2)
 154   2            {
 155   3               receive_data_finished_flag=1;
 156   3               data_count=0;
 157   3            }
 158   2            else 
 159   2            {
 160   3               data_count=0;
 161   3            }
 162   2         }
 163   1      
 164   1         if(receive_data_finished_flag==1)   //ËµÃ÷½ÓÊÕµ½ÁËÊý¾Ý£¬¿ªÊ¼´¦Àí
 165   1         {
 166   2            receive_data_finished_flag=0; //Çå½ÓÊÕ±êÖ¾
 167   2            Receiver_EN=0;       //¹Ø±Õ½ÓÊÕ»ú
 168   2            switch(received_data_buffer[2])//½âÎöÖ¸Áî
 169   2            {
 170   3               case ComMode_1://½ÓÊÕµ½µÄÊÇÖ÷»ú·¢ËÍ¹ýÀ´µÄ±àÂë1µÄÐÅºÅ£¬ËµÃ÷Ö÷»úÔÚ3MÄÚ£¬ÊÇÕý³£µÄ
 171   3               {  
 172   4                  leave_count=0;//Õý³£Çé¿ö£¬Çå³¬Ê±±êÖ¾
 173   4      
 174   4                  stolen_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 175   4                  stolen_alarm_flag=0;//Çå±¨¾¯±êÖ¾
C51 COMPILER V9.51   TIMER                                                                 11/14/2013 10:54:22 PAGE 4   

 176   4      
 177   4                  raised_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 178   4                  raised_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 179   4      
 180   4                  fell_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 181   4                  fell_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 182   4      
 183   4                  Moto_Vibration();
 184   4               }
 185   3               break;
 186   3            
 187   3               case ComMode_3:
 188   3               {
 189   4                  leave_count=0;//Çå³¬Ê±±êÖ¾          
 190   4                  stolen_alarm_flag=1;
 191   4      
 192   4                  raised_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 193   4                  raised_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 194   4                  fell_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 195   4                  fell_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 196   4      
 197   4                  Moto_Vibration();
 198   4               }
 199   3               break;
 200   3            
 201   3               case ComMode_4://Áô×÷Ì§ÆðÐÅºÅÊ¹ÓÃ
 202   3               {
 203   4                  leave_count=0;//Çå³¬Ê±±êÖ¾ 
 204   4                  raised_alarm_flag=1;//Ì§Æð±¨¾¯
 205   4      
 206   4                  stolen_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 207   4                  stolen_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 208   4                  fell_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 209   4                  fell_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 210   4      
 211   4                  Moto_Vibration();
 212   4               }
 213   3               break;
 214   3      
 215   3               case ComMode_5://Áô×÷µ¹µØÐÅºÅÊ¹ÓÃ
 216   3               {
 217   4                  leave_count=0;//Çå³¬Ê±±êÖ¾
 218   4                  fell_alarm_flag=1;   //µ¹µØ±¨¾¯
 219   4      
 220   4                  stolen_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 221   4                  stolen_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 222   4                  raised_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 223   4                  raised_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 224   4      
 225   4                  Moto_Vibration();
 226   4               }
 227   3               break;
 228   3      
 229   3               case ComMode_6:
 230   3               {
 231   4                  Host_battery_high_flag=1;
 232   4               }
 233   3               break;
 234   3            }
 235   2         }
 236   1      }
 237          
C51 COMPILER V9.51   TIMER                                                                 11/14/2013 10:54:22 PAGE 5   

 238          /*--------------------------------------------------
 239             InitTimer()
 240             
 241             ³õÊ¼»¯¶¨Ê±Æ÷T0ºÍT1
 242          ---------------------------------------------------*/
 243          
 244          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
 245             {
 246   1         tLong Inc_T0, Inc_T1;
 247   1         tWord timer0_16, timer1_16;
 248   1         
 249   1         //¼ÆËãTimer0µÄ¼Ä´æÆ÷Öµ
 250   1         Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
 251   1         timer0_16 = (tWord) (65536UL - Inc_T0);
 252   1         timer0_8H = (tByte) (timer0_16 / 256);
 253   1         timer0_8L = (tByte) (timer0_16 % 256);
 254   1         
 255   1         //¼ÆËãTimer1µÄ¼Ä´æÆ÷Öµ
 256   1         Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
 257   1         timer1_16 = (tWord) (65536UL - Inc_T1);
 258   1         timer1_8H = (tByte) (timer1_16 / 256);
 259   1         timer1_8L = (tByte) (timer1_16 % 256);
 260   1         
 261   1         TMOD = 0x11;
 262   1         TH0 = timer0_8H;
 263   1         TL0 = timer0_8L;
 264   1         TH1 = timer1_8H;
 265   1         TL1 = timer1_8L;
 266   1      
 267   1         ET0 = 1;
 268   1         TR0 = 1;
 269   1         ET1 = 1;
 270   1         TR1 = 1;
 271   1         PT1 = 1;       
 272   1         EA = 1;
 273   1         }
 274          
 275          /*---------------------------------------------------
 276             end of file
 277          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    516    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
