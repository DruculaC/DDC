C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE main.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*---------------------------------------------------
   2                  main.c (v1.00)
   3                  
   4                  DDC-F program, for electrocar.
   5          ----------------------------------------------------*/
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "AD.h"
  11          #include "T0.h"
  12          #include "voice.h"
  13          #include "pwm.h"
  14          #include "T1.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          
  18          /*--------------------------------------------------*/
  19          
  20          bit ModeFlag=0;                         //模式选择位，0则用模式1,1则用模式2
  21          bit receiveFlag=0;                      //接收到数据标志
  22          bit commuFlag=0;                        //开启通信标志
  23          
  24          bit alarmFlag2=0;                       //是否继续报警标志
  25          bit alarmFlag3=0;                       //是否继续报警标志
  26          bit alarmFlag4=0;                       //抬起报警
  27          bit alarmFlag5=0;                       //倒地报警
  28          unsigned int alarmCount2=0;     //报警2循环次数
  29          unsigned int alarmCount3=0;     //报警3循环次数
  30          unsigned int alarmCount4=0;     //抬起报警循环次数
  31          unsigned int alarmCount5=0;     //倒地报警循环次数
  32          
  33          unsigned char voiceFlag=0;      //声音循环开关 
  34          
  35          unsigned char dataFirst=0;      //用于存储上次编码类型
  36          
  37          unsigned char count=0;          //串口接收部分的计数器
  38           
  39          unsigned int time0Count_3=0;//作为串口每秒主辅机的信息交互时钟
  40          
  41          unsigned int lastAddr=0;        //上一次接收到的编码的地址
  42          unsigned int TestFlag=0;        //1、2、3分别为每1S后的计数，在串口的成功指令里会执行将去归零的操作
  43                                                  //如果连续3次都没有归零，则说明不在场了
  44          
  45          
  46          unsigned int Check=0;           //作为AD检测值
  47          bit checkFlag=0;                        //电量检测标志
  48           
  49          unsigned char DataBetween=0;    //作为接收数据的中间变量
  50          unsigned char RecData=0;                //接收到的数据
  51          unsigned char DataTime=0;               //作为接收的数据的移位次数计数
  52          bit ComFlag=1;                                  //做上升沿的一个标志
  53          unsigned char T1highcount=0;    //定时器T1在没有信号到来的时候，对高电平计数，一旦超过某个值，则将Datatime清0
  54          
  55          bit ADCcheck=0;                 //置1时，执行一次电量转换，执行完后，将其置0
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 2   

  56          bit sendcomm1=0;                //置1时，执行一次发送编码1，执行完后，将其置0
  57          bit sendspeech1=0;              //置1时，执行一次语音提示，表示充电已满
  58          unsigned char speech1_count=0;  
  59          unsigned char powerflag=1;              //电池电位的标记，1表示现在电池是满的，0表示还没满。
  60          
  61          
  62          tByte TxRxBuf[28]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
             -00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  63          tByte myTxRxData2[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};      //接收数据的缓存
  64          
  65          void main(void)
  66          {
  67   1              noVoice();
  68   1              InitT0();
  69   1              InitT1();
  70   1              Moto=1;                 //关闭马达
  71   1      
  72   1              ET0=1;
  73   1              ET1=1;
  74   1              PT1=1;                  //定时器1的中断优先级最高
  75   1              EA=1;
  76   1      
  77   1              myPwm();                //开发射机
  78   1              P10=1;
  79   1              PAshutdown=0;                   //开机时，将功放关闭
  80   1              
  81   1              Check=GetADCResult(6);  //上电时，电池电量检测一次
  82   1              
  83   1              commuFlag=1;                    //开启通信
  84   1              alarmCount3=0;                  //清报警计数器
  85   1              alarmFlag3=0;                   //清报警标志
  86   1      
  87   1      //      receive_en=1;
  88   1              tran_en=0;
  89   1      
  90   1              while(1)
  91   1              {
  92   2                      if(alarmFlag3==1)               //编码3开始相应的报警
  93   2                      {
  94   3                              if(alarmCount3<2)
  95   3                              {
  96   4                                      PAshutdown=1;
  97   4                                      SC_Speech(5);
  98   4                                      Delay(150);
  99   4                                      SC_Speech(6);
 100   4                                      Delay(80);
 101   4                                      SC_Speech(7);
 102   4                                      Delay(120);
 103   4                                      PAshutdown=0;
 104   4                                      
 105   4                                      Moto=0;                         
 106   4                                      Delay(10);
 107   4                                      Moto=1;
 108   4                                      alarmCount3++;
 109   4                              }
 110   3                      }
 111   2      
 112   2                      if(alarmFlag4==1)               //抬起开始相应的报警
 113   2                      {
 114   3      
 115   3                                      PAshutdown=1;
 116   3                                      SC_Speech(4);
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 3   

 117   3                                      Delay(180);
 118   3                                      
 119   3                                      Moto=0;
 120   3                                      Delay(10);
 121   3                                      Moto=1;
 122   3                                      alarmFlag4=0;
 123   3                      }
 124   2      
 125   2                      if(alarmFlag5==1)//倒地开始相应的报警
 126   2                      {
 127   3                                      PAshutdown=1;
 128   3                                      SC_Speech(8);
 129   3                                      Delay(180);
 130   3              
 131   3                                      Moto=0;//开震动
 132   3                                      Delay(10);
 133   3                                      Moto=1;
 134   3      
 135   3                                      alarmFlag5=0;
 136   3                      }
 137   2      
 138   2                      if(ADCcheck==1)                         //每个3s检测一次电量，如果电池满的就检测是否低了，如果是不满的就检测是否充满。
 139   2                      {
 140   3                              Check=GetADCResult(6);  //电池电量检测
 141   3                              ADCcheck=0;
 142   3                              
 143   3                              if((powerflag==1)&&(Check<=0x35a))
 144   3                              {
 145   4                                      powerflag=0;
 146   4                                      PAshutdown=1;
 147   4                                      SC_Speech(9);   //电压不充足提示
 148   4                                      Delay(120);
 149   4                                      PAshutdown=0;
 150   4                              }
 151   3                              else if((powerflag==0)&&(Check>=0x377))
 152   3                              {
 153   4                                      powerflag=1;
 154   4                                      PAshutdown=1;
 155   4                                      SC_Speech(2);   //电压充足提示
 156   4                                      Delay(120);
 157   4                                      PAshutdown=0;
 158   4                              }       
 159   3                      }
 160   2      
 161   2                      if(sendcomm1==1)
 162   2                      {
 163   3                              receive_en=0;           //打开接收机
 164   3                              ComMode_1_Data();       //发送模式1信号
 165   3                              receive_en=1;           //打开接收机
 166   3                              sendcomm1=0;
 167   3                      }
 168   2      
 169   2                      if(sendspeech1==1)
 170   2                      {
 171   3                              PAshutdown=1;
 172   3                              SC_Speech(2);  
 173   3                              Delay(80);
 174   3                              SC_Speech(3);  
 175   3                              Delay(80);
 176   3                              PAshutdown=0;
 177   3                              sendspeech1=0;
 178   3                      }
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 4   

 179   2              }
 180   1      }
 181          
 182          void timeT1() interrupt 3                               //定时器1中断接收数据
 183          {
 184   1              TH1=timer1H;                                            //重装载
 185   1              TL1=timer1L;
 186   1      
 187   1              if(P11==0)                                                      //正常情况为高电平,有低电平说明有信号
 188   1              {
 189   2                      DataBetween++;
 190   2                      ComFlag=0;
 191   2                      if(DataBetween==150)                    //低电平持续的最大时间  
 192   2                      {
 193   3                              DataBetween=0;
 194   3                      }
 195   2              }
 196   1              else//为高电平了
 197   1              {
 198   2                      if(ComFlag==0)//说明有一个低电平
 199   2                      {
 200   3                              ComFlag=1;
 201   3      //                      RecData<<=1;
 202   3      
 203   3                              if((DataBetween>60)&&(DataBetween<=100))//低电平持续的时间小于3ms，则为0
 204   3                              {
 205   4                                      RecData<<=1;
 206   4                                      RecData &= 0xfe;
 207   4                                      DataTime++;
 208   4                                      T1highcount=0;
 209   4                              }
 210   3                              if(DataBetween>100)//低电平持续的时间大于4.5ms，则为1
 211   3                              {
 212   4                                      RecData<<=1;
 213   4                                      RecData |= 0x01;
 214   4                                      DataTime++;
 215   4                                      T1highcount=0;
 216   4                              }
 217   3                              else
 218   3                              {
 219   4                                      T1highcount++;  
 220   4                              }
 221   3      
 222   3                              DataBetween=0;
 223   3                      }
 224   2                      else
 225   2                      {
 226   3                              T1highcount++;
 227   3                              if(T1highcount>=120)
 228   3                              {
 229   4                                      DataTime=0;
 230   4                                      ComFlag=1;
 231   4                                      count=0;
 232   4                              }               
 233   3                      }
 234   2              }
 235   1      
 236   1              if(DataTime==8)//说明一个字节的数据已经接受完全
 237   1              {
 238   2                      DataTime=0;
 239   2                      myTxRxData2[count]=RecData;
 240   2                      if(count==0&&myTxRxData2[0]==CmdHead)
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 5   

 241   2                      {
 242   3                              count=1;
 243   3                      }
 244   2                      else if(count==1&&myTxRxData2[1]==MyAddress)
 245   2                      {
 246   3                              count=2;
 247   3                      }
 248   2                      else if(count==2)
 249   2                      {
 250   3                              receiveFlag=1;
 251   3                              count=0;
 252   3                      }
 253   2                      else 
 254   2                      {
 255   3                              count=0;
 256   3                      }
 257   2      
 258   2      /*
 259   2                      else if(count>=2&&count<=5)
 260   2                      {
 261   2                              count++;
 262   2                      }
 263   2                      else if(count==6)
 264   2                      {
 265   2                              receiveFlag=1;
 266   2                              count=0;
 267   2                      }
 268   2                      else 
 269   2                      {
 270   2                              count=0;
 271   2                      }
 272   2      */
 273   2              }
 274   1      
 275   1              if(receiveFlag==1)      //说明接收到了数据，开始处理
 276   1              {
 277   2                      receiveFlag=0;  //清接收标志
 278   2                      receive_en=0;                   //关闭接收机
 279   2                      switch(myTxRxData2[2])//解析指令
 280   2                      {
 281   3                              case ComMode_1://接收到的是主机发送过来的编码1的信号，说明主机在3M内，是正常的
 282   3                              {       
 283   4                                      TestFlag=0;//正常情况，清超时标志
 284   4      
 285   4                                      alarmCount3=0;//清报警计数器
 286   4                                      alarmFlag3=0;//清报警标志
 287   4      
 288   4                                      alarmCount4=0;//清报警计数器
 289   4                                      alarmFlag4=0;//清报警标志
 290   4      
 291   4                                      alarmCount5=0;//清报警计数器
 292   4                                      alarmFlag5=0;//清报警标志
 293   4      
 294   4                                      Moto=0;//开震动
 295   4                                      Delay(10);
 296   4                                      Moto=1;
 297   4                              }
 298   3                              break;
 299   3                      
 300   3                              case ComMode_3:
 301   3                              {
 302   4                                      TestFlag=0;//清超时标志                         
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 6   

 303   4                                      alarmFlag3=1;
 304   4      
 305   4                                      alarmCount4=0;//清报警计数器
 306   4                                      alarmFlag4=0;//清报警标志
 307   4                                      alarmCount5=0;//清报警计数器
 308   4                                      alarmFlag5=0;//清报警标志
 309   4      
 310   4                                      Moto=0;         //开震动
 311   4                                      Delay(10);
 312   4                                      Moto=1;
 313   4                              }
 314   3                              break;
 315   3                      
 316   3                              case ComMode_4://留作抬起信号使用
 317   3                              {
 318   4                                      TestFlag=0;//清超时标志 
 319   4                                      alarmFlag4=1;//抬起报警
 320   4      
 321   4                                      alarmCount3=0;//清报警计数器
 322   4                                      alarmFlag3=0;//清报警标志
 323   4                                      alarmCount5=0;//清报警计数器
 324   4                                      alarmFlag5=0;//清报警标志
 325   4      
 326   4                                      Moto=0;         //开震动
 327   4                                      Delay(10);
 328   4                                      Moto=1;
 329   4                              }
 330   3                              break;
 331   3      
 332   3                              case ComMode_5://留作倒地信号使用
 333   3                              {
 334   4                                      TestFlag=0;//清超时标志
 335   4                                      alarmFlag5=1;   //倒地报警
 336   4      
 337   4                                      alarmCount3=0;//清报警计数器
 338   4                                      alarmFlag3=0;//清报警标志
 339   4                                      alarmCount4=0;//清报警计数器
 340   4                                      alarmFlag4=0;//清报警标志
 341   4      
 342   4                                      Moto=0;         //开震动
 343   4                                      Delay(10);
 344   4                                      Moto=1;
 345   4                              }
 346   3                              break;
 347   3      
 348   3                              case ComMode_6://留作倒地信号使用
 349   3                              {
 350   4                                      sendspeech1=1;
 351   4                              }
 352   3                              break;
 353   3                      }
 354   2              }
 355   1      }
 356          
 357          void time0() interrupt 1        //作为整个系统自己的时钟
 358          {
 359   1              TH0=timer0H;//重装载
 360   1              TL0=timer0L;
 361   1      
 362   1              time0Count_3++;
 363   1      
 364   1              if(time0Count_3>=60)            //串口每1S发送一次的数据的时间标志
C51 COMPILER V9.51   MAIN                                                                  09/27/2013 10:58:46 PAGE 7   

 365   1              {
 366   2                      ADCcheck=1;
 367   2                      if(commuFlag==1)                //说明开启了通信
 368   2                      {
 369   3                              TestFlag++;
 370   3                              sendcomm1=1;
 371   3                              if(TestFlag>=4)         //说明已经出了300M了。收不到任何信号了，要做报警
 372   3                              {
 373   4                                      TestFlag=5;
 374   4                              }
 375   3                      }
 376   2                      time0Count_3=0;
 377   2              }
 378   1      
 379   1              if(alarmCount3>=2)
 380   1              {
 381   2                      alarmCount3++;
 382   2                      if(alarmCount3==1800)
 383   2                      {
 384   3                              alarmCount3=0;
 385   3                              alarmFlag3=0;
 386   3                      }
 387   2              }
 388   1      }
 389          
 390          /*---------------------------------------------------
 391                  end of file
 392          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    743    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     60    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
